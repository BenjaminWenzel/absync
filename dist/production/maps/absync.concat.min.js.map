{"version":3,"sources":["_absync.module.js","absync.js","absync.concat.js","configuration.js"],"names":["angular","module","undefined","getAbsyncProvider","$provide","_absyncProvider","this","__ioSocket","__registerLater","__collections","configure","configuration","socket","io","Socket","Error","length","forEach","listener","__handleEntityEvent","eventName","callback","rootScope","collection","name","absyncCacheServiceFactory","service","$get","$rootScope","AbsyncService","$inject","parentProvider","scope","__absyncProvider","__scope","CacheService","$http","$injector","$log","$q","absync","_cacheService","info","_injector","injector","_injectorHasModel","has","model","_model","get","serializeModel","serialize","serializationNoop","deserializeModel","deserialize","entityCache","__entityCacheRaw","__dataAvailableDeferred","defer","__objectsAvailableDeferred","dataAvailable","promise","objectsAvailable","httpInterface","logInterface","q","serializer","deserializer","on","entityName","__onEntityOnWebsocket","bind","collectionName","__onCollectionOnWebsocket","$on","__onEntityReceived","__onCollectionReceived","then","__onDataAvailable","prototype","message","$broadcast","rawData","deserializeCollectionEntry","rawEntity","push","resolve","cache","event","args","_entityReceived","Object","keys","hasOwnProperty","__removeEntityFromCache","id","debug","__updateCacheWithEntity","addEntityToCache","entityReceived","deserialized","_collectionReceived","ensureLoaded","forceReload","onCollectionReceived","serverResponse","data","onCollectionRetrievalFailure","error","$emit","collectionUri","when","all","read","onEntityRetrieved","onEntityRetrievalFailure","entityIndex","entity","entityUri","update","afterEntityStored","newEntity","onEntityStorageFailure","reduced","reduceComplex","serialized","wrappedEntity","put","post","create","onEntityDeleted","entityId","onEntityDeletionFailed","status","headers","config","success","entityToCache","found","updated","targetEntity","copyFrom","extend","splice","lookupTableById","lookupTable","arrayInsteadOfObject","result","propertyName","Array","isArray","populateComplex","force","mapElementToPromise","element","index","onComplexRetrieved","complex","promises","map","provider","_absyncService","emit","_rootScope","arguments","$apply","apply","wrapper","removeListener","AbsyncServiceConfigurationFactory","AbsyncServiceConfiguration","_modelName","constructor","toLowerCase"],"mappings":"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","file":"absync.concat.min.js","sourcesContent":["(function() {\n\t\"use strict\";\n\n\tangular.module( \"absync\", [\n\t] );\n})();\n","(function( undefined ) {\n\t\"use strict\";\n\n\t/**\n\t * Please make note of the following variable naming conventions:\n\t * 1. Function-scope local variables must be prefixed with a single underscore.\n\t *    This indicates a temporary variable.\n\t * 2. Variables that are persisted onto publicly accessible entities must be prefixed with two underscores.\n\t *    This indicates a private variable.\n\t *    Hiding private variables, by using closures, is discouraged.\n\t */\n\n\tangular\n\t\t.module( \"absync\" )\n\t\t.provider( \"absync\", getAbsyncProvider );\n\n\t/* @ngInject */\n\tfunction getAbsyncProvider( $provide ) {\n\t\tvar _absyncProvider = this;\n\n\t\t_absyncProvider.__ioSocket = null;\n\t\t// If socket.io was not connected when a service was constructed, we put the registration request\n\t\t// into this array and register it as soon as socket.io is configured.\n\t\t_absyncProvider.__registerLater = [];\n\n\t\t// The collections that absync provides.\n\t\t_absyncProvider.__collections = {};\n\n\t\t// Register the configurator on the provider itself to allow early configuration during setup phase.\n\t\t_absyncProvider.configure = function AbsyncProvider$configure( configuration ) {\n\t\t\tvar socket = configuration.socket || configuration;\n\t\t\tif( typeof socket == \"function\" ) {\n\t\t\t\t// Assume io\n\t\t\t\t_absyncProvider.__ioSocket = socket();\n\n\t\t\t} else if( io && io.Socket && socket instanceof io.Socket ) {\n\t\t\t\t// Assume io.Socket\n\t\t\t\t_absyncProvider.__ioSocket = socket;\n\n\t\t\t} else {\n\t\t\t\tthrow new Error( \"configure() expects input to be a function or a socket.io Socket instance.\" );\n\t\t\t}\n\n\t\t\t// Check if services already tried to register listeners, if so, register them now.\n\t\t\tif( _absyncProvider.__registerLater.length ) {\n\t\t\t\tangular.forEach( _absyncProvider.__registerLater, function registerListener( listener ) {\n\t\t\t\t\tthis.__handleEntityEvent( listener.eventName, listener.callback, listener.rootScope );\n\t\t\t\t} );\n\t\t\t\t_absyncProvider.__registerLater = [];\n\t\t\t}\n\t\t};\n\n\t\t// Request a new synchronized collection.\n\t\t// This only registers the intent to use that collection. It will be constructed when it is first used.\n\t\t_absyncProvider.collection = function AbsyncProvider$collection( name, configuration ) {\n\t\t\tif( _absyncProvider.__collections[ name ] ) {\n\t\t\t\tthrow new Error( \"A collection with the name '\" + name + \"' was already requested. Names for collections must be unique.\" );\n\t\t\t}\n\n\t\t\t// Register the service configuration.\n\t\t\t// absyncCacheServiceFactory will return a constructor for a service with the given configuration.\n\t\t\t_absyncProvider.__collections[ name ] = absyncCacheServiceFactory( name, configuration );\n\n\t\t\t// Register the new service.\n\t\t\t// Yes, we want an Angular \"service\" here, because we want it constructed with \"new\".\n\t\t\t$provide.service( name, _absyncProvider.__collections[ name ] );\n\t\t};\n\n\t\t// Register the service factory.\n\t\t/* @ngInject */\n\t\t_absyncProvider.$get = function absyncProvider$$get( $rootScope ) {\n\t\t\treturn new AbsyncService( this, $rootScope );\n\t\t};\n\t}\n\n\t/**\n\t * The service that is received when injecting \"absync\".\n\t * This service is primarily used internally to set up the connection between socket.io and the individual\n\t * caching services.\n\t * @param {Object} parentProvider The AbsyncProvider that provides this service.\n\t * @param {Object} scope The Angular scope to use (usually the root scope).\n\t * @constructor\n\t */\n\tfunction AbsyncService( parentProvider, scope ) {\n\t\tthis.__absyncProvider = parentProvider;\n\t\tthis.__scope = scope;\n\t}\n\n\t/**\n\t * Configure the socket.io connection for absync.\n\t * @param configuration\n\t */\n\tAbsyncService.prototype.configure = function AbsyncService$configure( configuration ) {\n\t\tvar _absyncProvider = this.__absyncProvider;\n\t\t_absyncProvider.configure( configuration );\n\t};\n\n\t/**\n\t * Register an event listener that is called when a specific entity is received on the websocket.\n\t * @param {String} eventName\n\t * @param {Function} callback\n\t */\n\tAbsyncService.prototype.on = function AbsyncService$on( eventName, callback ) {\n\t\tvar _absyncProvider = this.__absyncProvider;\n\t\tvar _absyncService = this;\n\n\t\tif( !_absyncProvider.__ioSocket ) {\n\t\t\t_absyncProvider.__registerLater.push( {\n\t\t\t\teventName : eventName,\n\t\t\t\tcallback  : callback,\n\t\t\t\trootScope : _absyncProvider.__scope\n\t\t\t} );\n\t\t\treturn;\n\t\t}\n\n\t\t_absyncService.__handleEntityEvent( eventName, callback, _absyncService.__scope );\n\t};\n\n\t/**\n\t * Convenience method to allow the user to emit() from the websocket.\n\t * This is not utilized in absync internally.\n\t * @param {String} eventName\n\t * @param {*} data\n\t * @param {Function} callback\n\t */\n\tAbsyncService.prototype.emit = function AbsyncService$emit( eventName, data, callback ) {\n\t\tvar _absyncProvider = this.__absyncProvider;\n\n\t\tif( !_absyncProvider.__ioSocket ) {\n\t\t\tthrow new Error( \"socket.io is not initialized.\" );\n\t\t}\n\n\t\tvar _rootScope = this.rootScope;\n\n\t\t_absyncProvider.__ioSocket.emit( eventName, data, function afterEmit() {\n\t\t\tvar args = arguments;\n\t\t\t_rootScope.$apply( function() {\n\t\t\t\tif( callback ) {\n\t\t\t\t\tcallback.apply( _absyncProvider.__ioSocket, args );\n\t\t\t\t}\n\t\t\t} );\n\t\t} );\n\t};\n\n\t/**\n\t * Register an event listener on the websocket.\n\t * @param {String} eventName\n\t * @param {Function} callback\n\t * @param {Object} scope\n\t * @returns {Function}\n\t */\n\tAbsyncService.prototype.__handleEntityEvent = function AbsyncService$__handleEntityEvent( eventName, callback, scope ) {\n\t\tvar _absyncProvider = this.__absyncProvider;\n\n\t\tvar wrapper = function() {\n\t\t\tvar args = arguments;\n\t\t\tscope.$apply( function() {\n\t\t\t\tcallback.apply( _absyncProvider.__ioSocket, args );\n\t\t\t} );\n\t\t};\n\t\t_absyncProvider.__ioSocket.on( eventName, wrapper );\n\n\t\t// Return a function that removes the listener.\n\t\t// TODO: This is not currently utilized due to the delayed listener registration approach.\n\t\treturn function removeListener() {\n\t\t\t_absyncProvider.__ioSocket.removeListener( eventName, wrapper );\n\t\t};\n\t};\n\n\t/**\n\t * This factory serves as a closure to make the configuration available to the cache service.\n\t * @param {String} name The name of the service.\n\t * @param {AbsyncServiceConfiguration} configuration The configuration for this service.\n\t * @returns {CacheService}\n\t */\n\tfunction absyncCacheServiceFactory( name, configuration ) {\n\t\t// There is no code here, other than the CacheService definition, followed by \"return CacheService;\"\n\n\t\t/**\n\t\t * This service factory is the core of absync.\n\t\t * It returns a CacheService instance that is specialized to the given configuration.\n\t\t * This service will handle keep the stored collection in sync.\n\t\t * @returns {CacheService}\n\t\t * @ngInject\n\t\t */\n\t\tfunction CacheService( $http, $injector, $log, $q, $rootScope, absync ) {\n\t\t\tvar _cacheService = this;\n\t\t\t$log.info( \"absync service '\" + name + \"' was instantiated.\" );\n\n\t\t\t// Retrieve a reference to the model of the collection that is being cached.\n\t\t\tvar _injector = configuration.injector || $injector;\n\t\t\tvar _injectorHasModel = _injector.has( configuration.model );\n\t\t\tif( !_injectorHasModel ) {\n\t\t\t\tthrow new Error( \"Unable to construct the '\" + name + \"' service, because the referenced model '\" + configuration.model + \"' is not available for injection.\" );\n\t\t\t}\n\t\t\tvar _model = (typeof configuration.model === \"string\" ) ? _injector.get( configuration.model ) : configuration.model;\n\n\t\t\t// Retrieve the serialization methods.\n\t\t\tvar serializeModel = _model.serialize || configuration.serialize || serializationNoop;\n\t\t\tvar deserializeModel = _model.deserialize || configuration.deserialize || serializationNoop;\n\n\t\t\t// Store configuration.\n\t\t\t_cacheService.name = name;\n\t\t\t_cacheService.configuration = configuration;\n\n\t\t\t// The entity cache must be constructed as an empty array, to allow the user to place watchers on it.\n\t\t\t// We must never replace the cache with a new array, we must always manipulate the existing one.\n\t\t\t// Otherwise watchers will not behave as the user expects them to.\n\t\t\t/* @type {Array<configuration.model>} */\n\t\t\t_cacheService.entityCache = [];\n\t\t\t// The raw cache is data that hasn't been deserialized and is used internally.\n\t\t\t_cacheService.__entityCacheRaw = null;\n\n\t\t\t// TODO: Using deferreds is an anti-pattern and probably provides no value here.\n\t\t\t_cacheService.__dataAvailableDeferred = $q.defer();\n\t\t\t_cacheService.__objectsAvailableDeferred = $q.defer();\n\t\t\t// A promise that is resolved once initial data synchronization has taken place.\n\t\t\t_cacheService.dataAvailable = _cacheService.__dataAvailableDeferred.promise;\n\t\t\t// A promise that is resolved once the received data is extended to models.\n\t\t\t_cacheService.objectsAvailable = _cacheService.__objectsAvailableDeferred.promise;\n\n\t\t\t// Use $http by default and expose it on the service.\n\t\t\t// This allows the user to set a different, possibly decorated, HTTP interface for this service.\n\t\t\t_cacheService.httpInterface = $http;\n\t\t\t// Do the same for our logger.\n\t\t\t_cacheService.logInterface = $log;\n\t\t\t// The scope on which we broadcast all our relevant events.\n\t\t\t_cacheService.scope = $rootScope;\n\t\t\t// Keep a reference to $q.\n\t\t\t_cacheService.q = $q;\n\n\t\t\t// Expose the serializer/deserializer so that they can be adjusted at any time.\n\t\t\t_cacheService.serializer = serializeModel;\n\t\t\t_cacheService.deserializer = deserializeModel;\n\n\t\t\t// Tell absync to register an event listener for both our entity and its collection.\n\t\t\t// When we receive these events, we broadcast an equal Angular event on the root scope.\n\t\t\t// This way the user can already peek at the data (manipulating it is discouraged though).\n\t\t\tabsync.on( configuration.entityName, _cacheService.__onEntityOnWebsocket.bind( _cacheService ) );\n\t\t\tabsync.on( configuration.collectionName, _cacheService.__onCollectionOnWebsocket.bind( _cacheService ) );\n\n\t\t\t// Now we listen on the root scope for the same events we're firing above.\n\t\t\t// This is where our own absync synchronization logic kicks in.\n\t\t\t$rootScope.$on( configuration.entityName, _cacheService.__onEntityReceived.bind( _cacheService ) );\n\t\t\t$rootScope.$on( configuration.collectionName, _cacheService.__onCollectionReceived.bind( _cacheService ) );\n\n\t\t\t// Wait for data to be available.\n\t\t\t_cacheService.dataAvailable\n\t\t\t\t.then( _cacheService.__onDataAvailable.bind( _cacheService ) );\n\t\t}\n\n\t\t/**\n\t\t * Invoked when an entity is received on a websocket.\n\t\t * Translates the websocket event to an Angular event and broadcasts it on the scope.\n\t\t * @param {Object} message\n\t\t * @private\n\t\t */\n\t\tCacheService.prototype.__onEntityOnWebsocket = function CacheService$__onEntityOnWebsocket( message ) {\n\t\t\tvar _cacheService = this;\n\t\t\t_cacheService.scope.$broadcast( configuration.entityName, message[ configuration.entityName ] );\n\t\t};\n\n\t\t/**\n\t\t * Invoked when a collection is received on a websocket.\n\t\t * Translates the websocket event to an Angular event and broadcasts it on the scope.\n\t\t * @param {Object} message\n\t\t * @private\n\t\t */\n\t\tCacheService.prototype.__onCollectionOnWebsocket = function CacheService$__onCollectionOnWebsocket( message ) {\n\t\t\tvar _cacheService = this;\n\t\t\t_cacheService.scope.$broadcast( configuration.collectionName, message[ configuration.collectionName ] );\n\t\t};\n\n\t\t/**\n\t\t * Event handler for when the initial badge of raw data becomes available.\n\t\t * @param {Array<Object>} rawData\n\t\t * @private\n\t\t */\n\t\tCacheService.prototype.__onDataAvailable = function CacheService$__onDataAvailable( rawData ) {\n\t\t\tvar _cacheService = this;\n\n\t\t\t// _cacheService.entityCache is expected to be an empty array.\n\t\t\t// We initialize it in the constructor to an empty array and we don't expect any writes to have\n\t\t\t// happened to it. In case writes *did* happen, we assume that whoever wrote to it knows what\n\t\t\t// they're doing.\n\t\t\trawData[ configuration.collectionName ].forEach( deserializeCollectionEntry );\n\n\t\t\t// Resolve out \"objects are available\" deferred.\n\t\t\t// TODO: We could just as well initialize objectAvailable to the return value of this call block.\n\t\t\t_cacheService.__objectsAvailableDeferred.resolve( _cacheService.entityCache );\n\n\t\t\t// Notify the rest of the application about a fresh collection.\n\t\t\t_cacheService.scope.$broadcast( \"collectionNew\", {\n\t\t\t\tservice : _cacheService,\n\t\t\t\tcache   : _cacheService.entityCache\n\t\t\t} );\n\n\t\t\tfunction deserializeCollectionEntry( rawEntity ) {\n\t\t\t\t_cacheService.entityCache.push( _cacheService.deserializer( rawEntity ) );\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Event handler for when an entity is received on the root scope.\n\t\t * @param {Object} event The event object.\n\t\t * @param {Object} args The raw object as it was read from the wire.\n\t\t * @private\n\t\t */\n\t\tCacheService.prototype.__onEntityReceived = function CacheService$__onEntityReceived( event, args ) {\n\t\t\tvar _cacheService = this;\n\t\t\tvar _entityReceived = args;\n\n\t\t\t// Determine if the received record consists ONLY of an id property,\n\t\t\t// which would mean that this record was deleted from the backend.\n\t\t\tif( 1 === Object.keys( _entityReceived ).length && _entityReceived.hasOwnProperty( \"id\" ) ) {\n\t\t\t\t_cacheService.logInterface.info( \"Entity was deleted from the server. Updating cache…\" );\n\t\t\t\t_cacheService.__removeEntityFromCache( _entityReceived.id );\n\n\t\t\t} else {\n\t\t\t\t_cacheService.logInterface.debug( \"Entity was updated on the server. Updating cache…\" );\n\t\t\t\t_cacheService.__updateCacheWithEntity( _cacheService.deserializer( _entityReceived ) );\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Event handler for when a collection is received on the root scope.\n\t\t * @param {Object} event The event object.\n\t\t * @param {Array<Object>} args The raw collection as it was read from the wire.\n\t\t * @private\n\t\t */\n\t\tCacheService.prototype.__onCollectionReceived = function CacheService$__onCollectionReceived( event, args ) {\n\t\t\tvar _cacheService = this;\n\t\t\tvar _collectionReceived = args;\n\n\t\t\t// When we're receiving a full collection, all data we currently have in our cache is useless.\n\t\t\t// We reset the length of the array here, because assigning a new array would possibly conflict\n\t\t\t// with watchers placed on the original object.\n\t\t\twhile( 0 < _cacheService.entityCache.length ) {\n\t\t\t\t_cacheService.entityCache.length = 0;\n\t\t\t}\n\n\t\t\t// Deserialize the received data and place the models in our cache.\n\t\t\t_collectionReceived.forEach( addEntityToCache );\n\n\t\t\tfunction addEntityToCache( entityReceived ) {\n\t\t\t\tvar deserialized = _cacheService.deserializer( entityReceived );\n\t\t\t\t_cacheService.__updateCacheWithEntity( deserialized );\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Ensure that the cached collection is retrieved from the server.\n\t\t * @param {Boolean} [forceReload=false] Should the data be loaded, even if the service already has a local cache?\n\t\t * @returns {Promise<Array<configuration.model>>}\n\t\t */\n\t\tCacheService.prototype.ensureLoaded = function CacheService$ensureLoaded( forceReload ) {\n\t\t\tvar _cacheService = this;\n\n\t\t\tforceReload = (forceReload === true);\n\n\t\t\t// We only perform any loading, if we don't have raw data cached yet, or if we're forced.\n\t\t\tif( null === _cacheService.__entityCacheRaw || forceReload ) {\n\t\t\t\t_cacheService.__entityCacheRaw = [];\n\n\t\t\t\t// If the user did not provide information necessary to work with a collection, immediately return\n\t\t\t\t// a promise for an empty collection. The user could still use read() to grab individual entities.\n\t\t\t\tif( !configuration.collectionName || !configuration.collectionUri ) {\n\t\t\t\t\treturn _cacheService.q.when( [] );\n\t\t\t\t}\n\n\t\t\t\t_cacheService.logInterface.info( \"Retrieving '\" + configuration.collectionName + \"' collection…\" );\n\t\t\t\t_cacheService.httpInterface\n\t\t\t\t\t.get( configuration.collectionUri )\n\t\t\t\t\t.then( onCollectionReceived, onCollectionRetrievalFailure );\n\t\t\t}\n\n\t\t\t// Return a promise that is resolved once the data was read and converted to models.\n\t\t\t// When the promise is resolved, it will return a reference to the entity cache.\n\t\t\treturn _cacheService.q.all(\n\t\t\t\t[\n\t\t\t\t\t_cacheService.dataAvailable,\n\t\t\t\t\t_cacheService.objectsAvailable\n\t\t\t\t] )\n\t\t\t\t.then( function dataAvailable() {\n\t\t\t\t\treturn _cacheService.entityCache;\n\t\t\t\t} );\n\n\t\t\t/**\n\t\t\t * Invoked when the collection was received from the server.\n\t\t\t * @param {Object} serverResponse The reply sent from the server.\n\t\t\t */\n\t\t\tfunction onCollectionReceived( serverResponse ) {\n\t\t\t\tif( !serverResponse.data[ configuration.collectionName ] ) {\n\t\t\t\t\tthrow new Error( \"The response from the server was not in the expected format. It should have a member named '\" + configuration.collectionName + \"'.\" );\n\t\t\t\t}\n\n\t\t\t\t_cacheService.__entityCacheRaw = serverResponse.data;\n\t\t\t\t_cacheService.__dataAvailableDeferred.resolve( serverResponse.data );\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Invoked when there was an error while trying to retrieve the collection from the server.\n\t\t\t * @param {Error} error\n\t\t\t */\n\t\t\tfunction onCollectionRetrievalFailure( error ) {\n\t\t\t\t_cacheService.logInterface.error( \"Unable to retrieve the collection from the server.\", error );\n\t\t\t\t_cacheService.__entityCacheRaw = null;\n\t\t\t\t_cacheService.scope.$emit( \"absyncError\", error );\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Read a single entity from the cache, or load it from the server if required.\n\t\t * The entity will be placed into the cache.\n\t\t * @param {String} id The ID of the entity to retrieve.\n\t\t * @param {Boolean} [forceReload=false] Should the entity be retrieved from the server, even if it is already in the cache?\n\t\t * @returns {Promise<configuration.model>}\n\t\t */\n\t\tCacheService.prototype.read = function CacheService$read( id, forceReload ) {\n\t\t\tvar _cacheService = this;\n\n\t\t\tforceReload = (forceReload === true);\n\n\t\t\tif( !forceReload ) {\n\t\t\t\t// Check if the entity is in the cache and return instantly if found.\n\t\t\t\tfor( var entityIndex = 0, entity = _cacheService.entityCache[ 0 ];\n\t\t\t\t     entityIndex < _cacheService.entityCache.length;\n\t\t\t\t     ++entityIndex, entity = _cacheService.entityCache[ entityIndex ] ) {\n\t\t\t\t\tif( entity.id === id ) {\n\t\t\t\t\t\treturn _cacheService.q.when( entity );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Grab the entity from the backend.\n\t\t\treturn _cacheService.httpInterface\n\t\t\t\t.get( configuration.entityUri + \"/\" + id )\n\t\t\t\t.then( onEntityRetrieved, onEntityRetrievalFailure );\n\n\t\t\t/**\n\t\t\t * Invoked when the entity was retrieved from the server.\n\t\t\t * @param {Object} serverResponse The reply sent from the server.\n\t\t\t */\n\t\t\tfunction onEntityRetrieved( serverResponse ) {\n\t\t\t\tif( !serverResponse.data[ configuration.entityName ] ) {\n\t\t\t\t\tthrow new Error( \"The response from the server was not in the expected format. It should have a member named '\" + configuration.entityName + \"'.\" );\n\t\t\t\t}\n\n\t\t\t\t// Deserialize the object and place it into the cache.\n\t\t\t\t// We do not need to check here if the object already exists in the cache.\n\t\t\t\t// While it could be possible that the same entity is retrieved multiple times, __updateCacheWithEntity\n\t\t\t\t// will not insert duplicated into the cache.\n\t\t\t\tvar deserialized = _cacheService.deserializer( serverResponse.data[ configuration.entityName ] );\n\t\t\t\t_cacheService.__updateCacheWithEntity( deserialized );\n\t\t\t\treturn deserialized;\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Invoked when there was an error while trying to retrieve the entity from the server.\n\t\t\t * @param {Error} error\n\t\t\t */\n\t\t\tfunction onEntityRetrievalFailure( error ) {\n\t\t\t\t_cacheService.logInterface.error( \"Unable to retrieve entity with ID '\" + id + \"' from the server.\", error );\n\t\t\t\t_cacheService.scope.$emit( \"absyncError\", error );\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Updates an entity and persists it to the backend and the cache.\n\t\t * @param {configuration.model} entity\n\t\t * @return {Promise<configuration.model>} A promise that will be resolved with the updated entity.\n\t\t */\n\t\tCacheService.prototype.update = function CacheService$update( entity ) {\n\t\t\tvar _cacheService = this;\n\n\t\t\t// First create a copy of the object, which has complex properties reduced to their respective IDs.\n\t\t\tvar reduced = _cacheService.reduceComplex( entity );\n\t\t\t// Now serialize the object.\n\t\t\tvar serialized = _cacheService.serializer( reduced );\n\n\t\t\t// Wrap the entity in a new object, with a single property, named after the entity type.\n\t\t\tvar wrappedEntity = {};\n\t\t\twrappedEntity[ configuration.entityName ] = serialized;\n\n\t\t\t// Check if the entity has an \"id\" property, if it has, we will update. Otherwise, we create.\n\t\t\tif( \"undefined\" !== typeof( entity.id ) ) {\n\t\t\t\treturn _cacheService.httpInterface\n\t\t\t\t\t.put( configuration.entityUri + \"/\" + entity.id, wrappedEntity )\n\t\t\t\t\t.then( afterEntityStored, onEntityStorageFailure );\n\n\t\t\t} else {\n\t\t\t\t// Create a new entity\n\t\t\t\treturn _cacheService.httpInterface\n\t\t\t\t\t.post( configuration.collectionUri, wrappedEntity )\n\t\t\t\t\t.then( afterEntityStored, onEntityStorageFailure );\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Invoked when the entity was stored on the server.\n\t\t\t * @param {Object} serverResponse The reply sent from the server.\n\t\t\t */\n\t\t\tfunction afterEntityStored( serverResponse ) {\n\t\t\t\t// Writing an entity to the backend will usually invoke an update event to be\n\t\t\t\t// broadcast over websockets, where we would also retrieve the updated record.\n\t\t\t\t// We still put the updated record we receive here into the cache to ensure early consistency.\n\t\t\t\t// TODO: This might actually not be optimal. Consider only handling the websocket update.\n\t\t\t\tif( serverResponse.data[ configuration.entityName ] ) {\n\t\t\t\t\tvar newEntity = _cacheService.deserializer( serverResponse.data[ configuration.entityName ] );\n\t\t\t\t\t_cacheService.__updateCacheWithEntity( newEntity );\n\t\t\t\t\treturn newEntity;\n\t\t\t\t}\n\t\t\t\tthrow new Error( \"The response from the server was not in the expected format. It should have a member named '\" + configuration.entityName + \"'.\" );\n\t\t\t}\n\n\t\t\tfunction onEntityStorageFailure( error ) {\n\t\t\t\t_cacheService.logInterface.error( \"Unable to store entity on the server.\", error );\n\t\t\t\t_cacheService.logInterface.error( error );\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Creates a new entity and persists it to the backend and the cache.\n\t\t */\n\t\tCacheService.prototype.create = CacheService.prototype.update;\n\n\t\t/**\n\t\t * Remove an entity from the cache and have it deleted on the backend.\n\t\t * @param {Object} entity\n\t\t */\n\t\tCacheService.prototype.delete = function CacheService$delete( entity ) {\n\t\t\tvar _cacheService = this;\n\n\t\t\tvar entityId = entity.id;\n\t\t\treturn _cacheService.httpInterface\n\t\t\t\t.delete( configuration.entityUri + \"/\" + entityId )\n\t\t\t\t.success( onEntityDeleted )\n\t\t\t\t.error( onEntityDeletionFailed );\n\n\t\t\tfunction onEntityDeleted() {\n\t\t\t\treturn _cacheService.__removeEntityFromCache( entityId );\n\t\t\t}\n\n\t\t\tfunction onEntityDeletionFailed( data, status, headers, config ) {\n\t\t\t\t_cacheService.logInterface.error( data );\n\t\t\t\tthrow new Error( \"Unable to delete entity.\" );\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Put an entity into the cache or update the existing record if the entity was already in the cache.\n\t\t * @param {Object} entityToCache\n\t\t * @private\n\t\t */\n\t\tCacheService.prototype.__updateCacheWithEntity = function CacheService$__updateCacheWithEntity( entityToCache ) {\n\t\t\tvar _cacheService = this;\n\n\t\t\t_cacheService.logInterface.info( \"Updating entity in cache…\" );\n\n\t\t\tvar found = false;\n\t\t\tfor( var entityIndex = 0, entity = _cacheService.entityCache[ 0 ];\n\t\t\t     entityIndex < _cacheService.entityCache.length;\n\t\t\t     ++entityIndex, entity = _cacheService.entityCache[ entityIndex ] ) {\n\t\t\t\tif( entity.id == entityToCache.id ) {\n\t\t\t\t\t// Allow the user to intervene in the update process, before updating the entity.\n\t\t\t\t\t_cacheService.scope.$broadcast( \"beforeEntityUpdated\",\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tservice : _cacheService,\n\t\t\t\t\t\t\tcache   : _cacheService.entityCache,\n\t\t\t\t\t\t\tentity  : _cacheService.entityCache[ entityIndex ],\n\t\t\t\t\t\t\tupdated : entityToCache\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t// Use the \"copyFrom\" method on the entity, if it exists, otherwise use naive approach.\n\t\t\t\t\tvar targetEntity = _cacheService.entityCache[ entityIndex ];\n\t\t\t\t\tif( typeof targetEntity.copyFrom === \"function\" ) {\n\t\t\t\t\t\ttargetEntity.copyFrom( entityToCache );\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tangular.extend( targetEntity, entityToCache );\n\t\t\t\t\t}\n\n\t\t\t\t\tfound = true;\n\n\t\t\t\t\t// After updating the entity, send another event to allow the user to react.\n\t\t\t\t\t_cacheService.scope.$broadcast( \"entityUpdated\",\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tservice : _cacheService,\n\t\t\t\t\t\t\tcache   : _cacheService.entityCache,\n\t\t\t\t\t\t\tentity  : _cacheService.entityCache[ entityIndex ]\n\t\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If the entity wasn't found in our records, it's a new entity.\n\t\t\tif( !found ) {\n\t\t\t\t_cacheService.entityCache.push( entityToCache );\n\t\t\t\t_cacheService.scope.$broadcast( \"entityNew\", {\n\t\t\t\t\tservice : _cacheService,\n\t\t\t\t\tcache   : _cacheService.entityCache,\n\t\t\t\t\tentity  : entityToCache\n\t\t\t\t} );\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Removes an entity from the internal cache. The entity is not removed from the backend.\n\t\t * @param {String} id The ID of the entity to remove from the cache.\n\t\t * @private\n\t\t */\n\t\tCacheService.prototype.__removeEntityFromCache = function CacheService$__removeEntityFromCache( id ) {\n\t\t\tvar _cacheService = this;\n\n\t\t\tfor( var entityIndex = 0, entity = _cacheService.entityCache[ 0 ];\n\t\t\t     entityIndex < _cacheService.entityCache.length;\n\t\t\t     ++entityIndex, entity = _cacheService.entityCache[ entityIndex ] ) {\n\t\t\t\tif( entity.id == id ) {\n\t\t\t\t\t// Before removing the entity, allow the user to react.\n\t\t\t\t\t_cacheService.scope.$broadcast( \"beforeEntityRemoved\", {\n\t\t\t\t\t\tservice : _cacheService,\n\t\t\t\t\t\tcache   : _cacheService.entityCache,\n\t\t\t\t\t\tentity  : entity\n\t\t\t\t\t} );\n\n\t\t\t\t\t// Remove the entity from the cache.\n\t\t\t\t\t_cacheService.entityCache.splice( entityIndex, 1 );\n\n\t\t\t\t\t// Send another event to allow the user to take note of the removal.\n\t\t\t\t\t_cacheService.scope.$broadcast( \"entityRemoved\", {\n\t\t\t\t\t\tservice : _cacheService,\n\t\t\t\t\t\tcache   : _cacheService.entityCache,\n\t\t\t\t\t\tentity  : entity\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Retrieve an associative array of all cached entities, which uses the ID of the entity records as the key in the array.\n\t\t * This is a convenience method that is not utilized internally.\n\t\t * @returns {Array<configuration.model>}\n\t\t */\n\t\tCacheService.prototype.lookupTableById = function CacheService$lookupTableById() {\n\t\t\tvar _cacheService = this;\n\n\t\t\t//TODO: Keep a copy of the lookup table and only update it when the cached data updates\n\t\t\tvar lookupTable = [];\n\t\t\tfor( var entityIndex = 0;\n\t\t\t     entityIndex < _cacheService.entityCache.length;\n\t\t\t     ++entityIndex ) {\n\t\t\t\tlookupTable[ _cacheService.entityCache[ entityIndex ].id ] = _cacheService.entityCache[ entityIndex ];\n\t\t\t}\n\t\t\treturn lookupTable;\n\t\t};\n\n\t\t/**\n\t\t * Reduce instances of complex types within an entity with their respective IDs.\n\t\t * Note that no type checks are being performed. Every nested object with an \"id\" property is treated as a complex type.\n\t\t * @param {Object} entity The entity that should have its complex member reduced.\n\t\t * @param {Boolean} [arrayInsteadOfObject=false] true if the manipulated entity is an array; false if it's an object.\n\t\t * @returns {Object|Array} A copy of the input entity, with complex type instances replaced with their respective ID.\n\t\t */\n\t\tCacheService.prototype.reduceComplex = function CacheService$reduceComplex( entity, arrayInsteadOfObject ) {\n\t\t\tvar _cacheService = this;\n\n\t\t\tvar result = arrayInsteadOfObject ? [] : {};\n\t\t\tfor( var propertyName in entity ) {\n\t\t\t\tif( !entity.hasOwnProperty( propertyName ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse for nested arrays.\n\t\t\t\tif( Array.isArray( entity[ propertyName ] ) ) {\n\t\t\t\t\tresult[ propertyName ] = _cacheService.reduceComplex( entity[ propertyName ], true );\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Replace complex type with its ID.\n\t\t\t\tif( entity[ propertyName ] && entity[ propertyName ].id ) {\n\t\t\t\t\tresult[ propertyName ] = entity[ propertyName ].id;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Just copy over the plain property.\n\t\t\t\tresult[ propertyName ] = entity[ propertyName ];\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\n\t\t/**\n\t\t * Populate references to complex types in an instance.\n\t\t * @param {Object} entity The entity that should be manipulated.\n\t\t * @param {String} propertyName The name of the property of entity which should be populated.\n\t\t * @param {CacheService} cache An instance of another caching service that can provide the complex\n\t\t * type instances which are being referenced in entity.\n\t\t * @param {Boolean} [force=false] If true, all complex types will be replaced with references to the\n\t\t * instances in cache; otherwise, only properties that are string representations of complex type IDs will be replaced.\n\t\t * @returns {Promise}\n\t\t */\n\t\tCacheService.prototype.populateComplex = function CacheService$populateComplex( entity, propertyName, cache, force ) {\n\t\t\tvar _cacheService = this;\n\n\t\t\t// If the target property is an array, ...\n\t\t\tif( Array.isArray( entity[ propertyName ] ) ) {\n\t\t\t\t// ...map the elements in the array to promises.\n\t\t\t\tvar promises = entity[ propertyName ].map( mapElementToPromise );\n\n\t\t\t\treturn _cacheService.q.all( promises );\n\n\t\t\t} else {\n\t\t\t\t// We usually assume the properties to be strings (the ID of the referenced complex).\n\t\t\t\tif( typeof entity[ propertyName ] !== \"string\" ) {\n\t\t\t\t\t// If \"force\" is enabled, we check if this non-string property is an object and has an \"id\" member, which is a string.\n\t\t\t\t\tif( force && typeof entity[ propertyName ] === \"object\" && typeof entity[ propertyName ].id === \"string\" ) {\n\t\t\t\t\t\t// If that is true, then we replace the whole object with the ID and continue as usual.\n\t\t\t\t\t\tentity[ propertyName ] = entity[ propertyName ].id;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn _cacheService.q.when( false );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Treat the property as an ID and read the complex with that ID from the cache.\n\t\t\t\treturn cache.read( entity[ propertyName ] )\n\t\t\t\t\t.then( onComplexRetrieved );\n\t\t\t}\n\n\t\t\tfunction mapElementToPromise( element, index ) {\n\t\t\t\t// We usually assume the properties to be strings (the ID of the referenced complex).\n\t\t\t\tif( typeof entity[ propertyName ][ index ] !== \"string\" ) {\n\t\t\t\t\t// If \"force\" is enabled, we check if this non-string property is an object and has an \"id\" member, which is a string.\n\t\t\t\t\tif( force && typeof entity[ propertyName ][ index ] === \"object\" && typeof entity[ propertyName ][ index ].id === \"string\" ) {\n\t\t\t\t\t\t// If that is true, then we replace the whole object with the ID and continue as usual.\n\t\t\t\t\t\tentity[ propertyName ][ index ] = entity[ propertyName ][ index ].id;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn _cacheService.q.when( false );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Treat the property as an ID and read the complex with that ID from the cache.\n\t\t\t\treturn cache.read( entity[ propertyName ][ index ] )\n\t\t\t\t\t.then( onComplexRetrieved );\n\n\t\t\t\tfunction onComplexRetrieved( complex ) {\n\t\t\t\t\t// When the complex was retrieved, store it back into the array.\n\t\t\t\t\tentity[ propertyName ][ index ] = complex;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction onComplexRetrieved( complex ) {\n\t\t\t\t// When the complex was retrieved, store it back into the entity.\n\t\t\t\tentity[ propertyName ] = complex;\n\t\t\t}\n\t\t};\n\n\t\treturn CacheService;\n\t}\n\n\tfunction serializationNoop( model ) {\n\t\treturn model;\n\t}\n\n}());\n","(function() {\n\t\"use strict\";\n\n\tangular.module( \"absync\", [\n\t] );\n})();\n;(function( undefined ) {\n\t\"use strict\";\n\n\t/**\n\t * Please make note of the following variable naming conventions:\n\t * 1. Function-scope local variables must be prefixed with a single underscore.\n\t *    This indicates a temporary variable.\n\t * 2. Variables that are persisted onto publicly accessible entities must be prefixed with two underscores.\n\t *    This indicates a private variable.\n\t *    Hiding private variables, by using closures, is discouraged.\n\t */\n\n\tangular\n\t\t.module( \"absync\" )\n\t\t.provider( \"absync\", getAbsyncProvider );\n\n\t/* @ngInject */\n\tfunction getAbsyncProvider( $provide ) {\n\t\tvar _absyncProvider = this;\n\n\t\t_absyncProvider.__ioSocket = null;\n\t\t// If socket.io was not connected when a service was constructed, we put the registration request\n\t\t// into this array and register it as soon as socket.io is configured.\n\t\t_absyncProvider.__registerLater = [];\n\n\t\t// The collections that absync provides.\n\t\t_absyncProvider.__collections = {};\n\n\t\t// Register the configurator on the provider itself to allow early configuration during setup phase.\n\t\t_absyncProvider.configure = function AbsyncProvider$configure( configuration ) {\n\t\t\tvar socket = configuration.socket || configuration;\n\t\t\tif( typeof socket == \"function\" ) {\n\t\t\t\t// Assume io\n\t\t\t\t_absyncProvider.__ioSocket = socket();\n\n\t\t\t} else if( io && io.Socket && socket instanceof io.Socket ) {\n\t\t\t\t// Assume io.Socket\n\t\t\t\t_absyncProvider.__ioSocket = socket;\n\n\t\t\t} else {\n\t\t\t\tthrow new Error( \"configure() expects input to be a function or a socket.io Socket instance.\" );\n\t\t\t}\n\n\t\t\t// Check if services already tried to register listeners, if so, register them now.\n\t\t\tif( _absyncProvider.__registerLater.length ) {\n\t\t\t\tangular.forEach( _absyncProvider.__registerLater, function registerListener( listener ) {\n\t\t\t\t\tthis.__handleEntityEvent( listener.eventName, listener.callback, listener.rootScope );\n\t\t\t\t} );\n\t\t\t\t_absyncProvider.__registerLater = [];\n\t\t\t}\n\t\t};\n\n\t\t// Request a new synchronized collection.\n\t\t// This only registers the intent to use that collection. It will be constructed when it is first used.\n\t\t_absyncProvider.collection = function AbsyncProvider$collection( name, configuration ) {\n\t\t\tif( _absyncProvider.__collections[ name ] ) {\n\t\t\t\tthrow new Error( \"A collection with the name '\" + name + \"' was already requested. Names for collections must be unique.\" );\n\t\t\t}\n\n\t\t\t// Register the service configuration.\n\t\t\t// absyncCacheServiceFactory will return a constructor for a service with the given configuration.\n\t\t\t_absyncProvider.__collections[ name ] = absyncCacheServiceFactory( name, configuration );\n\n\t\t\t// Register the new service.\n\t\t\t// Yes, we want an Angular \"service\" here, because we want it constructed with \"new\".\n\t\t\t$provide.service( name, _absyncProvider.__collections[ name ] );\n\t\t};\n\n\t\t// Register the service factory.\n\t\t/* @ngInject */\n\t\t_absyncProvider.$get = function absyncProvider$$get( $rootScope ) {\n\t\t\treturn new AbsyncService( this, $rootScope );\n\t\t};\r\n\t\t_absyncProvider.$get.$inject = [\"$rootScope\"];\n\t}\r\n\tgetAbsyncProvider.$inject = [\"$provide\"];\n\n\t/**\n\t * The service that is received when injecting \"absync\".\n\t * This service is primarily used internally to set up the connection between socket.io and the individual\n\t * caching services.\n\t * @param {Object} parentProvider The AbsyncProvider that provides this service.\n\t * @param {Object} scope The Angular scope to use (usually the root scope).\n\t * @constructor\n\t */\n\tfunction AbsyncService( parentProvider, scope ) {\n\t\tthis.__absyncProvider = parentProvider;\n\t\tthis.__scope = scope;\n\t}\n\n\t/**\n\t * Configure the socket.io connection for absync.\n\t * @param configuration\n\t */\n\tAbsyncService.prototype.configure = function AbsyncService$configure( configuration ) {\n\t\tvar _absyncProvider = this.__absyncProvider;\n\t\t_absyncProvider.configure( configuration );\n\t};\n\n\t/**\n\t * Register an event listener that is called when a specific entity is received on the websocket.\n\t * @param {String} eventName\n\t * @param {Function} callback\n\t */\n\tAbsyncService.prototype.on = function AbsyncService$on( eventName, callback ) {\n\t\tvar _absyncProvider = this.__absyncProvider;\n\t\tvar _absyncService = this;\n\n\t\tif( !_absyncProvider.__ioSocket ) {\n\t\t\t_absyncProvider.__registerLater.push( {\n\t\t\t\teventName : eventName,\n\t\t\t\tcallback  : callback,\n\t\t\t\trootScope : _absyncProvider.__scope\n\t\t\t} );\n\t\t\treturn;\n\t\t}\n\n\t\t_absyncService.__handleEntityEvent( eventName, callback, _absyncService.__scope );\n\t};\n\n\t/**\n\t * Convenience method to allow the user to emit() from the websocket.\n\t * This is not utilized in absync internally.\n\t * @param {String} eventName\n\t * @param {*} data\n\t * @param {Function} callback\n\t */\n\tAbsyncService.prototype.emit = function AbsyncService$emit( eventName, data, callback ) {\n\t\tvar _absyncProvider = this.__absyncProvider;\n\n\t\tif( !_absyncProvider.__ioSocket ) {\n\t\t\tthrow new Error( \"socket.io is not initialized.\" );\n\t\t}\n\n\t\tvar _rootScope = this.rootScope;\n\n\t\t_absyncProvider.__ioSocket.emit( eventName, data, function afterEmit() {\n\t\t\tvar args = arguments;\n\t\t\t_rootScope.$apply( function() {\n\t\t\t\tif( callback ) {\n\t\t\t\t\tcallback.apply( _absyncProvider.__ioSocket, args );\n\t\t\t\t}\n\t\t\t} );\n\t\t} );\n\t};\n\n\t/**\n\t * Register an event listener on the websocket.\n\t * @param {String} eventName\n\t * @param {Function} callback\n\t * @param {Object} scope\n\t * @returns {Function}\n\t */\n\tAbsyncService.prototype.__handleEntityEvent = function AbsyncService$__handleEntityEvent( eventName, callback, scope ) {\n\t\tvar _absyncProvider = this.__absyncProvider;\n\n\t\tvar wrapper = function() {\n\t\t\tvar args = arguments;\n\t\t\tscope.$apply( function() {\n\t\t\t\tcallback.apply( _absyncProvider.__ioSocket, args );\n\t\t\t} );\n\t\t};\n\t\t_absyncProvider.__ioSocket.on( eventName, wrapper );\n\n\t\t// Return a function that removes the listener.\n\t\t// TODO: This is not currently utilized due to the delayed listener registration approach.\n\t\treturn function removeListener() {\n\t\t\t_absyncProvider.__ioSocket.removeListener( eventName, wrapper );\n\t\t};\n\t};\n\n\t/**\n\t * This factory serves as a closure to make the configuration available to the cache service.\n\t * @param {String} name The name of the service.\n\t * @param {AbsyncServiceConfiguration} configuration The configuration for this service.\n\t * @returns {CacheService}\n\t */\n\tfunction absyncCacheServiceFactory( name, configuration ) {\n\t\t// There is no code here, other than the CacheService definition, followed by \"return CacheService;\"\n\n\t\t/**\n\t\t * This service factory is the core of absync.\n\t\t * It returns a CacheService instance that is specialized to the given configuration.\n\t\t * This service will handle keep the stored collection in sync.\n\t\t * @returns {CacheService}\n\t\t * @ngInject\n\t\t */\n\t\tfunction CacheService( $http, $injector, $log, $q, $rootScope, absync ) {\n\t\t\tvar _cacheService = this;\n\t\t\t$log.info( \"absync service '\" + name + \"' was instantiated.\" );\n\n\t\t\t// Retrieve a reference to the model of the collection that is being cached.\n\t\t\tvar _injector = configuration.injector || $injector;\n\t\t\tvar _injectorHasModel = _injector.has( configuration.model );\n\t\t\tif( !_injectorHasModel ) {\n\t\t\t\tthrow new Error( \"Unable to construct the '\" + name + \"' service, because the referenced model '\" + configuration.model + \"' is not available for injection.\" );\n\t\t\t}\n\t\t\tvar _model = (typeof configuration.model === \"string\" ) ? _injector.get( configuration.model ) : configuration.model;\n\n\t\t\t// Retrieve the serialization methods.\n\t\t\tvar serializeModel = _model.serialize || configuration.serialize || serializationNoop;\n\t\t\tvar deserializeModel = _model.deserialize || configuration.deserialize || serializationNoop;\n\n\t\t\t// Store configuration.\n\t\t\t_cacheService.name = name;\n\t\t\t_cacheService.configuration = configuration;\n\n\t\t\t// The entity cache must be constructed as an empty array, to allow the user to place watchers on it.\n\t\t\t// We must never replace the cache with a new array, we must always manipulate the existing one.\n\t\t\t// Otherwise watchers will not behave as the user expects them to.\n\t\t\t/* @type {Array<configuration.model>} */\n\t\t\t_cacheService.entityCache = [];\n\t\t\t// The raw cache is data that hasn't been deserialized and is used internally.\n\t\t\t_cacheService.__entityCacheRaw = null;\n\n\t\t\t// TODO: Using deferreds is an anti-pattern and probably provides no value here.\n\t\t\t_cacheService.__dataAvailableDeferred = $q.defer();\n\t\t\t_cacheService.__objectsAvailableDeferred = $q.defer();\n\t\t\t// A promise that is resolved once initial data synchronization has taken place.\n\t\t\t_cacheService.dataAvailable = _cacheService.__dataAvailableDeferred.promise;\n\t\t\t// A promise that is resolved once the received data is extended to models.\n\t\t\t_cacheService.objectsAvailable = _cacheService.__objectsAvailableDeferred.promise;\n\n\t\t\t// Use $http by default and expose it on the service.\n\t\t\t// This allows the user to set a different, possibly decorated, HTTP interface for this service.\n\t\t\t_cacheService.httpInterface = $http;\n\t\t\t// Do the same for our logger.\n\t\t\t_cacheService.logInterface = $log;\n\t\t\t// The scope on which we broadcast all our relevant events.\n\t\t\t_cacheService.scope = $rootScope;\n\t\t\t// Keep a reference to $q.\n\t\t\t_cacheService.q = $q;\n\n\t\t\t// Expose the serializer/deserializer so that they can be adjusted at any time.\n\t\t\t_cacheService.serializer = serializeModel;\n\t\t\t_cacheService.deserializer = deserializeModel;\n\n\t\t\t// Tell absync to register an event listener for both our entity and its collection.\n\t\t\t// When we receive these events, we broadcast an equal Angular event on the root scope.\n\t\t\t// This way the user can already peek at the data (manipulating it is discouraged though).\n\t\t\tabsync.on( configuration.entityName, _cacheService.__onEntityOnWebsocket.bind( _cacheService ) );\n\t\t\tabsync.on( configuration.collectionName, _cacheService.__onCollectionOnWebsocket.bind( _cacheService ) );\n\n\t\t\t// Now we listen on the root scope for the same events we're firing above.\n\t\t\t// This is where our own absync synchronization logic kicks in.\n\t\t\t$rootScope.$on( configuration.entityName, _cacheService.__onEntityReceived.bind( _cacheService ) );\n\t\t\t$rootScope.$on( configuration.collectionName, _cacheService.__onCollectionReceived.bind( _cacheService ) );\n\n\t\t\t// Wait for data to be available.\n\t\t\t_cacheService.dataAvailable\n\t\t\t\t.then( _cacheService.__onDataAvailable.bind( _cacheService ) );\n\t\t}\r\n\t\tCacheService.$inject = [\"$http\", \"$injector\", \"$log\", \"$q\", \"$rootScope\", \"absync\"];\n\n\t\t/**\n\t\t * Invoked when an entity is received on a websocket.\n\t\t * Translates the websocket event to an Angular event and broadcasts it on the scope.\n\t\t * @param {Object} message\n\t\t * @private\n\t\t */\n\t\tCacheService.prototype.__onEntityOnWebsocket = function CacheService$__onEntityOnWebsocket( message ) {\n\t\t\tvar _cacheService = this;\n\t\t\t_cacheService.scope.$broadcast( configuration.entityName, message[ configuration.entityName ] );\n\t\t};\n\n\t\t/**\n\t\t * Invoked when a collection is received on a websocket.\n\t\t * Translates the websocket event to an Angular event and broadcasts it on the scope.\n\t\t * @param {Object} message\n\t\t * @private\n\t\t */\n\t\tCacheService.prototype.__onCollectionOnWebsocket = function CacheService$__onCollectionOnWebsocket( message ) {\n\t\t\tvar _cacheService = this;\n\t\t\t_cacheService.scope.$broadcast( configuration.collectionName, message[ configuration.collectionName ] );\n\t\t};\n\n\t\t/**\n\t\t * Event handler for when the initial badge of raw data becomes available.\n\t\t * @param {Array<Object>} rawData\n\t\t * @private\n\t\t */\n\t\tCacheService.prototype.__onDataAvailable = function CacheService$__onDataAvailable( rawData ) {\n\t\t\tvar _cacheService = this;\n\n\t\t\t// _cacheService.entityCache is expected to be an empty array.\n\t\t\t// We initialize it in the constructor to an empty array and we don't expect any writes to have\n\t\t\t// happened to it. In case writes *did* happen, we assume that whoever wrote to it knows what\n\t\t\t// they're doing.\n\t\t\trawData[ configuration.collectionName ].forEach( deserializeCollectionEntry );\n\n\t\t\t// Resolve out \"objects are available\" deferred.\n\t\t\t// TODO: We could just as well initialize objectAvailable to the return value of this call block.\n\t\t\t_cacheService.__objectsAvailableDeferred.resolve( _cacheService.entityCache );\n\n\t\t\t// Notify the rest of the application about a fresh collection.\n\t\t\t_cacheService.scope.$broadcast( \"collectionNew\", {\n\t\t\t\tservice : _cacheService,\n\t\t\t\tcache   : _cacheService.entityCache\n\t\t\t} );\n\n\t\t\tfunction deserializeCollectionEntry( rawEntity ) {\n\t\t\t\t_cacheService.entityCache.push( _cacheService.deserializer( rawEntity ) );\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Event handler for when an entity is received on the root scope.\n\t\t * @param {Object} event The event object.\n\t\t * @param {Object} args The raw object as it was read from the wire.\n\t\t * @private\n\t\t */\n\t\tCacheService.prototype.__onEntityReceived = function CacheService$__onEntityReceived( event, args ) {\n\t\t\tvar _cacheService = this;\n\t\t\tvar _entityReceived = args;\n\n\t\t\t// Determine if the received record consists ONLY of an id property,\n\t\t\t// which would mean that this record was deleted from the backend.\n\t\t\tif( 1 === Object.keys( _entityReceived ).length && _entityReceived.hasOwnProperty( \"id\" ) ) {\n\t\t\t\t_cacheService.logInterface.info( \"Entity was deleted from the server. Updating cache…\" );\n\t\t\t\t_cacheService.__removeEntityFromCache( _entityReceived.id );\n\n\t\t\t} else {\n\t\t\t\t_cacheService.logInterface.debug( \"Entity was updated on the server. Updating cache…\" );\n\t\t\t\t_cacheService.__updateCacheWithEntity( _cacheService.deserializer( _entityReceived ) );\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Event handler for when a collection is received on the root scope.\n\t\t * @param {Object} event The event object.\n\t\t * @param {Array<Object>} args The raw collection as it was read from the wire.\n\t\t * @private\n\t\t */\n\t\tCacheService.prototype.__onCollectionReceived = function CacheService$__onCollectionReceived( event, args ) {\n\t\t\tvar _cacheService = this;\n\t\t\tvar _collectionReceived = args;\n\n\t\t\t// When we're receiving a full collection, all data we currently have in our cache is useless.\n\t\t\t// We reset the length of the array here, because assigning a new array would possibly conflict\n\t\t\t// with watchers placed on the original object.\n\t\t\twhile( 0 < _cacheService.entityCache.length ) {\n\t\t\t\t_cacheService.entityCache.length = 0;\n\t\t\t}\n\n\t\t\t// Deserialize the received data and place the models in our cache.\n\t\t\t_collectionReceived.forEach( addEntityToCache );\n\n\t\t\tfunction addEntityToCache( entityReceived ) {\n\t\t\t\tvar deserialized = _cacheService.deserializer( entityReceived );\n\t\t\t\t_cacheService.__updateCacheWithEntity( deserialized );\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Ensure that the cached collection is retrieved from the server.\n\t\t * @param {Boolean} [forceReload=false] Should the data be loaded, even if the service already has a local cache?\n\t\t * @returns {Promise<Array<configuration.model>>}\n\t\t */\n\t\tCacheService.prototype.ensureLoaded = function CacheService$ensureLoaded( forceReload ) {\n\t\t\tvar _cacheService = this;\n\n\t\t\tforceReload = (forceReload === true);\n\n\t\t\t// We only perform any loading, if we don't have raw data cached yet, or if we're forced.\n\t\t\tif( null === _cacheService.__entityCacheRaw || forceReload ) {\n\t\t\t\t_cacheService.__entityCacheRaw = [];\n\n\t\t\t\t// If the user did not provide information necessary to work with a collection, immediately return\n\t\t\t\t// a promise for an empty collection. The user could still use read() to grab individual entities.\n\t\t\t\tif( !configuration.collectionName || !configuration.collectionUri ) {\n\t\t\t\t\treturn _cacheService.q.when( [] );\n\t\t\t\t}\n\n\t\t\t\t_cacheService.logInterface.info( \"Retrieving '\" + configuration.collectionName + \"' collection…\" );\n\t\t\t\t_cacheService.httpInterface\n\t\t\t\t\t.get( configuration.collectionUri )\n\t\t\t\t\t.then( onCollectionReceived, onCollectionRetrievalFailure );\n\t\t\t}\n\n\t\t\t// Return a promise that is resolved once the data was read and converted to models.\n\t\t\t// When the promise is resolved, it will return a reference to the entity cache.\n\t\t\treturn _cacheService.q.all(\n\t\t\t\t[\n\t\t\t\t\t_cacheService.dataAvailable,\n\t\t\t\t\t_cacheService.objectsAvailable\n\t\t\t\t] )\n\t\t\t\t.then( function dataAvailable() {\n\t\t\t\t\treturn _cacheService.entityCache;\n\t\t\t\t} );\n\n\t\t\t/**\n\t\t\t * Invoked when the collection was received from the server.\n\t\t\t * @param {Object} serverResponse The reply sent from the server.\n\t\t\t */\n\t\t\tfunction onCollectionReceived( serverResponse ) {\n\t\t\t\tif( !serverResponse.data[ configuration.collectionName ] ) {\n\t\t\t\t\tthrow new Error( \"The response from the server was not in the expected format. It should have a member named '\" + configuration.collectionName + \"'.\" );\n\t\t\t\t}\n\n\t\t\t\t_cacheService.__entityCacheRaw = serverResponse.data;\n\t\t\t\t_cacheService.__dataAvailableDeferred.resolve( serverResponse.data );\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Invoked when there was an error while trying to retrieve the collection from the server.\n\t\t\t * @param {Error} error\n\t\t\t */\n\t\t\tfunction onCollectionRetrievalFailure( error ) {\n\t\t\t\t_cacheService.logInterface.error( \"Unable to retrieve the collection from the server.\", error );\n\t\t\t\t_cacheService.__entityCacheRaw = null;\n\t\t\t\t_cacheService.scope.$emit( \"absyncError\", error );\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Read a single entity from the cache, or load it from the server if required.\n\t\t * The entity will be placed into the cache.\n\t\t * @param {String} id The ID of the entity to retrieve.\n\t\t * @param {Boolean} [forceReload=false] Should the entity be retrieved from the server, even if it is already in the cache?\n\t\t * @returns {Promise<configuration.model>}\n\t\t */\n\t\tCacheService.prototype.read = function CacheService$read( id, forceReload ) {\n\t\t\tvar _cacheService = this;\n\n\t\t\tforceReload = (forceReload === true);\n\n\t\t\tif( !forceReload ) {\n\t\t\t\t// Check if the entity is in the cache and return instantly if found.\n\t\t\t\tfor( var entityIndex = 0, entity = _cacheService.entityCache[ 0 ];\n\t\t\t\t     entityIndex < _cacheService.entityCache.length;\n\t\t\t\t     ++entityIndex, entity = _cacheService.entityCache[ entityIndex ] ) {\n\t\t\t\t\tif( entity.id === id ) {\n\t\t\t\t\t\treturn _cacheService.q.when( entity );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Grab the entity from the backend.\n\t\t\treturn _cacheService.httpInterface\n\t\t\t\t.get( configuration.entityUri + \"/\" + id )\n\t\t\t\t.then( onEntityRetrieved, onEntityRetrievalFailure );\n\n\t\t\t/**\n\t\t\t * Invoked when the entity was retrieved from the server.\n\t\t\t * @param {Object} serverResponse The reply sent from the server.\n\t\t\t */\n\t\t\tfunction onEntityRetrieved( serverResponse ) {\n\t\t\t\tif( !serverResponse.data[ configuration.entityName ] ) {\n\t\t\t\t\tthrow new Error( \"The response from the server was not in the expected format. It should have a member named '\" + configuration.entityName + \"'.\" );\n\t\t\t\t}\n\n\t\t\t\t// Deserialize the object and place it into the cache.\n\t\t\t\t// We do not need to check here if the object already exists in the cache.\n\t\t\t\t// While it could be possible that the same entity is retrieved multiple times, __updateCacheWithEntity\n\t\t\t\t// will not insert duplicated into the cache.\n\t\t\t\tvar deserialized = _cacheService.deserializer( serverResponse.data[ configuration.entityName ] );\n\t\t\t\t_cacheService.__updateCacheWithEntity( deserialized );\n\t\t\t\treturn deserialized;\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Invoked when there was an error while trying to retrieve the entity from the server.\n\t\t\t * @param {Error} error\n\t\t\t */\n\t\t\tfunction onEntityRetrievalFailure( error ) {\n\t\t\t\t_cacheService.logInterface.error( \"Unable to retrieve entity with ID '\" + id + \"' from the server.\", error );\n\t\t\t\t_cacheService.scope.$emit( \"absyncError\", error );\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Updates an entity and persists it to the backend and the cache.\n\t\t * @param {configuration.model} entity\n\t\t * @return {Promise<configuration.model>} A promise that will be resolved with the updated entity.\n\t\t */\n\t\tCacheService.prototype.update = function CacheService$update( entity ) {\n\t\t\tvar _cacheService = this;\n\n\t\t\t// First create a copy of the object, which has complex properties reduced to their respective IDs.\n\t\t\tvar reduced = _cacheService.reduceComplex( entity );\n\t\t\t// Now serialize the object.\n\t\t\tvar serialized = _cacheService.serializer( reduced );\n\n\t\t\t// Wrap the entity in a new object, with a single property, named after the entity type.\n\t\t\tvar wrappedEntity = {};\n\t\t\twrappedEntity[ configuration.entityName ] = serialized;\n\n\t\t\t// Check if the entity has an \"id\" property, if it has, we will update. Otherwise, we create.\n\t\t\tif( \"undefined\" !== typeof( entity.id ) ) {\n\t\t\t\treturn _cacheService.httpInterface\n\t\t\t\t\t.put( configuration.entityUri + \"/\" + entity.id, wrappedEntity )\n\t\t\t\t\t.then( afterEntityStored, onEntityStorageFailure );\n\n\t\t\t} else {\n\t\t\t\t// Create a new entity\n\t\t\t\treturn _cacheService.httpInterface\n\t\t\t\t\t.post( configuration.collectionUri, wrappedEntity )\n\t\t\t\t\t.then( afterEntityStored, onEntityStorageFailure );\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Invoked when the entity was stored on the server.\n\t\t\t * @param {Object} serverResponse The reply sent from the server.\n\t\t\t */\n\t\t\tfunction afterEntityStored( serverResponse ) {\n\t\t\t\t// Writing an entity to the backend will usually invoke an update event to be\n\t\t\t\t// broadcast over websockets, where we would also retrieve the updated record.\n\t\t\t\t// We still put the updated record we receive here into the cache to ensure early consistency.\n\t\t\t\t// TODO: This might actually not be optimal. Consider only handling the websocket update.\n\t\t\t\tif( serverResponse.data[ configuration.entityName ] ) {\n\t\t\t\t\tvar newEntity = _cacheService.deserializer( serverResponse.data[ configuration.entityName ] );\n\t\t\t\t\t_cacheService.__updateCacheWithEntity( newEntity );\n\t\t\t\t\treturn newEntity;\n\t\t\t\t}\n\t\t\t\tthrow new Error( \"The response from the server was not in the expected format. It should have a member named '\" + configuration.entityName + \"'.\" );\n\t\t\t}\n\n\t\t\tfunction onEntityStorageFailure( error ) {\n\t\t\t\t_cacheService.logInterface.error( \"Unable to store entity on the server.\", error );\n\t\t\t\t_cacheService.logInterface.error( error );\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Creates a new entity and persists it to the backend and the cache.\n\t\t */\n\t\tCacheService.prototype.create = CacheService.prototype.update;\n\n\t\t/**\n\t\t * Remove an entity from the cache and have it deleted on the backend.\n\t\t * @param {Object} entity\n\t\t */\n\t\tCacheService.prototype.delete = function CacheService$delete( entity ) {\n\t\t\tvar _cacheService = this;\n\n\t\t\tvar entityId = entity.id;\n\t\t\treturn _cacheService.httpInterface\n\t\t\t\t.delete( configuration.entityUri + \"/\" + entityId )\n\t\t\t\t.success( onEntityDeleted )\n\t\t\t\t.error( onEntityDeletionFailed );\n\n\t\t\tfunction onEntityDeleted() {\n\t\t\t\treturn _cacheService.__removeEntityFromCache( entityId );\n\t\t\t}\n\n\t\t\tfunction onEntityDeletionFailed( data, status, headers, config ) {\n\t\t\t\t_cacheService.logInterface.error( data );\n\t\t\t\tthrow new Error( \"Unable to delete entity.\" );\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Put an entity into the cache or update the existing record if the entity was already in the cache.\n\t\t * @param {Object} entityToCache\n\t\t * @private\n\t\t */\n\t\tCacheService.prototype.__updateCacheWithEntity = function CacheService$__updateCacheWithEntity( entityToCache ) {\n\t\t\tvar _cacheService = this;\n\n\t\t\t_cacheService.logInterface.info( \"Updating entity in cache…\" );\n\n\t\t\tvar found = false;\n\t\t\tfor( var entityIndex = 0, entity = _cacheService.entityCache[ 0 ];\n\t\t\t     entityIndex < _cacheService.entityCache.length;\n\t\t\t     ++entityIndex, entity = _cacheService.entityCache[ entityIndex ] ) {\n\t\t\t\tif( entity.id == entityToCache.id ) {\n\t\t\t\t\t// Allow the user to intervene in the update process, before updating the entity.\n\t\t\t\t\t_cacheService.scope.$broadcast( \"beforeEntityUpdated\",\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tservice : _cacheService,\n\t\t\t\t\t\t\tcache   : _cacheService.entityCache,\n\t\t\t\t\t\t\tentity  : _cacheService.entityCache[ entityIndex ],\n\t\t\t\t\t\t\tupdated : entityToCache\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t// Use the \"copyFrom\" method on the entity, if it exists, otherwise use naive approach.\n\t\t\t\t\tvar targetEntity = _cacheService.entityCache[ entityIndex ];\n\t\t\t\t\tif( typeof targetEntity.copyFrom === \"function\" ) {\n\t\t\t\t\t\ttargetEntity.copyFrom( entityToCache );\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tangular.extend( targetEntity, entityToCache );\n\t\t\t\t\t}\n\n\t\t\t\t\tfound = true;\n\n\t\t\t\t\t// After updating the entity, send another event to allow the user to react.\n\t\t\t\t\t_cacheService.scope.$broadcast( \"entityUpdated\",\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tservice : _cacheService,\n\t\t\t\t\t\t\tcache   : _cacheService.entityCache,\n\t\t\t\t\t\t\tentity  : _cacheService.entityCache[ entityIndex ]\n\t\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If the entity wasn't found in our records, it's a new entity.\n\t\t\tif( !found ) {\n\t\t\t\t_cacheService.entityCache.push( entityToCache );\n\t\t\t\t_cacheService.scope.$broadcast( \"entityNew\", {\n\t\t\t\t\tservice : _cacheService,\n\t\t\t\t\tcache   : _cacheService.entityCache,\n\t\t\t\t\tentity  : entityToCache\n\t\t\t\t} );\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Removes an entity from the internal cache. The entity is not removed from the backend.\n\t\t * @param {String} id The ID of the entity to remove from the cache.\n\t\t * @private\n\t\t */\n\t\tCacheService.prototype.__removeEntityFromCache = function CacheService$__removeEntityFromCache( id ) {\n\t\t\tvar _cacheService = this;\n\n\t\t\tfor( var entityIndex = 0, entity = _cacheService.entityCache[ 0 ];\n\t\t\t     entityIndex < _cacheService.entityCache.length;\n\t\t\t     ++entityIndex, entity = _cacheService.entityCache[ entityIndex ] ) {\n\t\t\t\tif( entity.id == id ) {\n\t\t\t\t\t// Before removing the entity, allow the user to react.\n\t\t\t\t\t_cacheService.scope.$broadcast( \"beforeEntityRemoved\", {\n\t\t\t\t\t\tservice : _cacheService,\n\t\t\t\t\t\tcache   : _cacheService.entityCache,\n\t\t\t\t\t\tentity  : entity\n\t\t\t\t\t} );\n\n\t\t\t\t\t// Remove the entity from the cache.\n\t\t\t\t\t_cacheService.entityCache.splice( entityIndex, 1 );\n\n\t\t\t\t\t// Send another event to allow the user to take note of the removal.\n\t\t\t\t\t_cacheService.scope.$broadcast( \"entityRemoved\", {\n\t\t\t\t\t\tservice : _cacheService,\n\t\t\t\t\t\tcache   : _cacheService.entityCache,\n\t\t\t\t\t\tentity  : entity\n\t\t\t\t\t} );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Retrieve an associative array of all cached entities, which uses the ID of the entity records as the key in the array.\n\t\t * This is a convenience method that is not utilized internally.\n\t\t * @returns {Array<configuration.model>}\n\t\t */\n\t\tCacheService.prototype.lookupTableById = function CacheService$lookupTableById() {\n\t\t\tvar _cacheService = this;\n\n\t\t\t//TODO: Keep a copy of the lookup table and only update it when the cached data updates\n\t\t\tvar lookupTable = [];\n\t\t\tfor( var entityIndex = 0;\n\t\t\t     entityIndex < _cacheService.entityCache.length;\n\t\t\t     ++entityIndex ) {\n\t\t\t\tlookupTable[ _cacheService.entityCache[ entityIndex ].id ] = _cacheService.entityCache[ entityIndex ];\n\t\t\t}\n\t\t\treturn lookupTable;\n\t\t};\n\n\t\t/**\n\t\t * Reduce instances of complex types within an entity with their respective IDs.\n\t\t * Note that no type checks are being performed. Every nested object with an \"id\" property is treated as a complex type.\n\t\t * @param {Object} entity The entity that should have its complex member reduced.\n\t\t * @param {Boolean} [arrayInsteadOfObject=false] true if the manipulated entity is an array; false if it's an object.\n\t\t * @returns {Object|Array} A copy of the input entity, with complex type instances replaced with their respective ID.\n\t\t */\n\t\tCacheService.prototype.reduceComplex = function CacheService$reduceComplex( entity, arrayInsteadOfObject ) {\n\t\t\tvar _cacheService = this;\n\n\t\t\tvar result = arrayInsteadOfObject ? [] : {};\n\t\t\tfor( var propertyName in entity ) {\n\t\t\t\tif( !entity.hasOwnProperty( propertyName ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse for nested arrays.\n\t\t\t\tif( Array.isArray( entity[ propertyName ] ) ) {\n\t\t\t\t\tresult[ propertyName ] = _cacheService.reduceComplex( entity[ propertyName ], true );\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Replace complex type with its ID.\n\t\t\t\tif( entity[ propertyName ] && entity[ propertyName ].id ) {\n\t\t\t\t\tresult[ propertyName ] = entity[ propertyName ].id;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Just copy over the plain property.\n\t\t\t\tresult[ propertyName ] = entity[ propertyName ];\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\n\t\t/**\n\t\t * Populate references to complex types in an instance.\n\t\t * @param {Object} entity The entity that should be manipulated.\n\t\t * @param {String} propertyName The name of the property of entity which should be populated.\n\t\t * @param {CacheService} cache An instance of another caching service that can provide the complex\n\t\t * type instances which are being referenced in entity.\n\t\t * @param {Boolean} [force=false] If true, all complex types will be replaced with references to the\n\t\t * instances in cache; otherwise, only properties that are string representations of complex type IDs will be replaced.\n\t\t * @returns {Promise}\n\t\t */\n\t\tCacheService.prototype.populateComplex = function CacheService$populateComplex( entity, propertyName, cache, force ) {\n\t\t\tvar _cacheService = this;\n\n\t\t\t// If the target property is an array, ...\n\t\t\tif( Array.isArray( entity[ propertyName ] ) ) {\n\t\t\t\t// ...map the elements in the array to promises.\n\t\t\t\tvar promises = entity[ propertyName ].map( mapElementToPromise );\n\n\t\t\t\treturn _cacheService.q.all( promises );\n\n\t\t\t} else {\n\t\t\t\t// We usually assume the properties to be strings (the ID of the referenced complex).\n\t\t\t\tif( typeof entity[ propertyName ] !== \"string\" ) {\n\t\t\t\t\t// If \"force\" is enabled, we check if this non-string property is an object and has an \"id\" member, which is a string.\n\t\t\t\t\tif( force && typeof entity[ propertyName ] === \"object\" && typeof entity[ propertyName ].id === \"string\" ) {\n\t\t\t\t\t\t// If that is true, then we replace the whole object with the ID and continue as usual.\n\t\t\t\t\t\tentity[ propertyName ] = entity[ propertyName ].id;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn _cacheService.q.when( false );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Treat the property as an ID and read the complex with that ID from the cache.\n\t\t\t\treturn cache.read( entity[ propertyName ] )\n\t\t\t\t\t.then( onComplexRetrieved );\n\t\t\t}\n\n\t\t\tfunction mapElementToPromise( element, index ) {\n\t\t\t\t// We usually assume the properties to be strings (the ID of the referenced complex).\n\t\t\t\tif( typeof entity[ propertyName ][ index ] !== \"string\" ) {\n\t\t\t\t\t// If \"force\" is enabled, we check if this non-string property is an object and has an \"id\" member, which is a string.\n\t\t\t\t\tif( force && typeof entity[ propertyName ][ index ] === \"object\" && typeof entity[ propertyName ][ index ].id === \"string\" ) {\n\t\t\t\t\t\t// If that is true, then we replace the whole object with the ID and continue as usual.\n\t\t\t\t\t\tentity[ propertyName ][ index ] = entity[ propertyName ][ index ].id;\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn _cacheService.q.when( false );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Treat the property as an ID and read the complex with that ID from the cache.\n\t\t\t\treturn cache.read( entity[ propertyName ][ index ] )\n\t\t\t\t\t.then( onComplexRetrieved );\n\n\t\t\t\tfunction onComplexRetrieved( complex ) {\n\t\t\t\t\t// When the complex was retrieved, store it back into the array.\n\t\t\t\t\tentity[ propertyName ][ index ] = complex;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction onComplexRetrieved( complex ) {\n\t\t\t\t// When the complex was retrieved, store it back into the entity.\n\t\t\t\tentity[ propertyName ] = complex;\n\t\t\t}\n\t\t};\n\n\t\treturn CacheService;\n\t}\n\n\tfunction serializationNoop( model ) {\n\t\treturn model;\n\t}\n\n}());\n;(function( undefined ) {\n\t\"use strict\";\n\n\tangular\n\t\t.module( \"absync\" )\n\t\t.service( \"AbsyncServiceConfiguration\", AbsyncServiceConfigurationFactory );\n\n\tfunction AbsyncServiceConfigurationFactory() {\n\t\treturn AbsyncServiceConfiguration;\n\t}\n\n\t/**\n\t * Configuration for an absync service.\n\t * Using this type is entirely optional. Providing a hash with the same configuration options will work just fine.\n\t * @param {Object|String} model Reference to a constructor for the model type, or it's name.\n\t * If a name is given, absync will try to retrieve instances of the type through injection.\n\t * @param {String} collectionUri The REST API URI where the collection can be found.\n\t * Must not end with /\n\t * @param {String} entityUri The REST API URI where single entities out of the collection can be found.\n\t * Must not end with /\n\t * @param {String} [collectionName] The name of the collection. Uses the model name suffixed with \"s\" by default.\n\t * Using the default value is not recommended.\n\t * @param {String} [entityName] The name of an entity. Uses the model name by default.\n\t * Using the default value is not recommended.\n\t * @param {Function} [deserialize] A function that takes an object received from the server and turns it into a model.\n\t * By default, absync will just store the raw object without extending it to the model type.\n\t * Deserializers operate on the actual data received from the websocket.\n\t * @param {Function} [serialize] A function that takes a model and turns it into something the server expects.\n\t * By default, absync will just send the complete model.\n\t * Serializers operate on a copy of the actual model, which already had complex members reduced to their IDs.\n\t * @param {Function} [injector] An injector to use for model instantiation. Uses $injector by default.\n\t * Usually, you don't need to provide an alternative here.\n\t * @constructor\n\t */\n\tfunction AbsyncServiceConfiguration( model, collectionUri, entityUri, collectionName, entityName, deserialize, serialize, injector ) {\n\t\tthis.model = model;\n\t\tthis.collectionUri = collectionUri;\n\t\tthis.entityUri = entityUri;\n\n\t\tvar _modelName = model.prototype.constructor.name.toLowerCase();\n\t\tthis.collectionName = collectionName || ( _modelName + \"s\" );\n\t\tthis.entityName = entityName || _modelName;\n\n\t\tthis.deserialize = deserialize || undefined;\n\t\tthis.serialize = serialize || undefined;\n\n\t\tthis.injector = injector || undefined;\n\t}\n\n}());\n","(function( undefined ) {\n\t\"use strict\";\n\n\tangular\n\t\t.module( \"absync\" )\n\t\t.service( \"AbsyncServiceConfiguration\", AbsyncServiceConfigurationFactory );\n\n\tfunction AbsyncServiceConfigurationFactory() {\n\t\treturn AbsyncServiceConfiguration;\n\t}\n\n\t/**\n\t * Configuration for an absync service.\n\t * Using this type is entirely optional. Providing a hash with the same configuration options will work just fine.\n\t * @param {Object|String} model Reference to a constructor for the model type, or it's name.\n\t * If a name is given, absync will try to retrieve instances of the type through injection.\n\t * @param {String} collectionUri The REST API URI where the collection can be found.\n\t * Must not end with /\n\t * @param {String} entityUri The REST API URI where single entities out of the collection can be found.\n\t * Must not end with /\n\t * @param {String} [collectionName] The name of the collection. Uses the model name suffixed with \"s\" by default.\n\t * Using the default value is not recommended.\n\t * @param {String} [entityName] The name of an entity. Uses the model name by default.\n\t * Using the default value is not recommended.\n\t * @param {Function} [deserialize] A function that takes an object received from the server and turns it into a model.\n\t * By default, absync will just store the raw object without extending it to the model type.\n\t * Deserializers operate on the actual data received from the websocket.\n\t * @param {Function} [serialize] A function that takes a model and turns it into something the server expects.\n\t * By default, absync will just send the complete model.\n\t * Serializers operate on a copy of the actual model, which already had complex members reduced to their IDs.\n\t * @param {Function} [injector] An injector to use for model instantiation. Uses $injector by default.\n\t * Usually, you don't need to provide an alternative here.\n\t * @constructor\n\t */\n\tfunction AbsyncServiceConfiguration( model, collectionUri, entityUri, collectionName, entityName, deserialize, serialize, injector ) {\n\t\tthis.model = model;\n\t\tthis.collectionUri = collectionUri;\n\t\tthis.entityUri = entityUri;\n\n\t\tvar _modelName = model.prototype.constructor.name.toLowerCase();\n\t\tthis.collectionName = collectionName || ( _modelName + \"s\" );\n\t\tthis.entityName = entityName || _modelName;\n\n\t\tthis.deserialize = deserialize || undefined;\n\t\tthis.serialize = serialize || undefined;\n\n\t\tthis.injector = injector || undefined;\n\t}\n\n}());\n"],"sourceRoot":"/source/"}