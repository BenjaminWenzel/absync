{"version":3,"sources":["_absync.module.js","absync.js","absync.concat.js"],"names":["angular","module","undefined","getAbsyncProvider","$injector","$provide","_absyncProvider","this","__ioSocket","__registerLater","__collections","configure","configuration","socket","io","Socket","Error","length","forEach","listener","__handleEntityEvent","eventName","callback","rootScope","collection","name","absyncCacheServiceFactoryFactory","factory","$get","$rootScope","AbsyncService","$inject","parentProvider","__absyncProvider","__rootScope","absyncCacheServiceFactory","$http","$log","$q","absync","updateCacheWithEntity","entityToCache","info","found","entityIndex","entity","cacheService","entityCache","cacheSize","id","$broadcast","service","cache","updated","targetEntity","copyFrom","extend","push","removeEntityFromCache","splice","collectionName","_injector","injector","_injectorHasModel","has","model","_model","get","serializeModel","serialize","serializationNoop","deserializeModel","deserialize","entityCacheRaw","dataAvailableDeferred","defer","objectsAvailableDeferred","dataAvailable","promise","objectsAvailable","httpInterface","serializer","deserializer","ensureLoaded","forceReload","collectionUri","then","peopleResult","data","resolve","error","$emit","all","rawData","rawEntity","read","onEntityRetrieved","entityName","deferred","reject","entityUri","success","update","reduced","reduceComplex","serialized","wrapper","put","result","newEntity","post","create","entityId","status","headers","config","lookupTableById","lookupTable","arrayInsteadOfObject","propertyName","hasOwnProperty","Array","isArray","populateComplex","force","promises","map","element","index","when","complex","$on","event","args","entityReceived","Object","keys","collectionReceived","pop","on","message","provider","prototype","_absyncService","emit","ioSocket","_rootScope","arguments","$apply","apply","removeListener"],"mappings":"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","file":"absync.concat.min.js","sourcesContent":["(function() {\n\t\"use strict\";\n\n\tangular.module( \"absync\", [\n\t] );\n})();\n","(function( undefined ) {\n\t\"use strict\";\n\n\t/**\n\t * Please make note of the following variable naming conventions:\n\t * 1. Function-scope local variables must be prefixed with a single underscore.\n\t *    This indicates a temporary variable.\n\t * 2. Variables that are persisted onto publicly accessible entities must be prefixed with two underscores.\n\t *    This indicates a private variable.\n\t *    Hiding private variables, by using closures, is discouraged.\n\t */\n\n\tangular\n\t\t.module( \"absync\" )\n\t\t.provider( \"absync\", getAbsyncProvider );\n\n\t/* @ngInject */\n\tfunction getAbsyncProvider( $injector, $provide ) {\n\t\tvar _absyncProvider = this;\n\n\t\t_absyncProvider.__ioSocket = null;\n\t\t// If socket.io was not connected when a service was constructed, we put the registration request\n\t\t// into this array and register it as soon as socket.io is configured.\n\t\t_absyncProvider.__registerLater = [];\n\n\t\t// The collections that absync provides.\n\t\t_absyncProvider.__collections = {};\n\n\t\t// Register the configurator on the provider itself to allow early configuration during setup phase.\n\t\t_absyncProvider.configure = function AbsyncProvider$configure( configuration ) {\n\t\t\tvar socket = configuration.socket || configuration;\n\t\t\tif( typeof socket == \"function\" ) {\n\t\t\t\t// Assume io\n\t\t\t\t_absyncProvider.__ioSocket = socket();\n\n\t\t\t} else if( io && io.Socket && socket instanceof io.Socket ) {\n\t\t\t\t// Assume io.Socket\n\t\t\t\t_absyncProvider.__ioSocket = socket;\n\n\t\t\t} else {\n\t\t\t\tthrow new Error( \"configure() expects input to be a function or a socket.io Socket instance.\" );\n\t\t\t}\n\n\t\t\t// Check if services already tried to register listeners, if so, register them now.\n\t\t\tif( _absyncProvider.__registerLater.length ) {\n\t\t\t\tangular.forEach( _absyncProvider.__registerLater, function registerListener( listener ) {\n\t\t\t\t\tthis.__handleEntityEvent( listener.eventName, listener.callback, listener.rootScope );\n\t\t\t\t} );\n\t\t\t\t_absyncProvider.__registerLater = [];\n\t\t\t}\n\t\t};\n\n\t\t// Request a new synchronized collection.\n\t\t// This only registers the intent to use that collection. It will be constructed when it is first used.\n\t\t_absyncProvider.collection = function AbsyncProvider$collection( name, configuration ) {\n\t\t\tif( _absyncProvider.__collections[ name ] ) {\n\t\t\t\tthrow new Error( \"A collection with the name '\" + name + \"' was already requested. Names for collections must be unique.\" );\n\t\t\t}\n\n\t\t\t// Register the service configuration.\n\t\t\t_absyncProvider.__collections[ name ] = absyncCacheServiceFactoryFactory( name, configuration );\n\n\t\t\t// Register the new service.\n\t\t\t$provide\n\t\t\t\t.factory( name, _absyncProvider.__collections[ name ] );\n\t\t};\n\n\t\t// Register the service factory.\n\t\t/* @ngInject */\n\t\t_absyncProvider.$get = function absyncProvider$$get( $rootScope ) {\n\t\t\treturn new AbsyncService( this, $rootScope );\n\t\t};\n\t}\n\n\t/**\n\t * The service that is received when injecting \"absync\".\n\t * This service is primarily used internally to set up the connection between socket.io and the individual\n\t * caching services.\n\t * @param {Object} parentProvider The AbsyncProvider that provides this service.\n\t * @param {Object} rootScope The Angular root scope.\n\t * @constructor\n\t */\n\tfunction AbsyncService( parentProvider, rootScope ) {\n\t\tthis.__absyncProvider = parentProvider;\n\t\tthis.__rootScope = rootScope;\n\t}\n\n\t/**\n\t * Configure the socket.io connection for absync.\n\t * @param configuration\n\t */\n\tAbsyncService.prototype.configure = function AbsyncService$configure( configuration ) {\n\t\tvar _absyncProvider = this.__absyncProvider;\n\t\t_absyncProvider.configure( configuration );\n\t};\n\n\t/**\n\t * Register an event listener that is called when a specific entity is received on the websocket.\n\t * @param eventName\n\t * @param callback\n\t */\n\tAbsyncService.prototype.on = function AbsyncService$on( eventName, callback ) {\n\t\tvar _absyncProvider = this.__absyncProvider;\n\t\tvar _absyncService = this;\n\n\t\tif( !_absyncProvider.__ioSocket ) {\n\t\t\t_absyncProvider.__registerLater.push( {\n\t\t\t\teventName : eventName,\n\t\t\t\tcallback  : callback,\n\t\t\t\trootScope : _absyncProvider.__rootScope\n\t\t\t} );\n\t\t\treturn;\n\t\t}\n\n\t\tthis.__handleEntityEvent( eventName, callback, _absyncService.__rootScope );\n\t};\n\n\t/**\n\t * Convenience method to allow the user to emit() from the websocket.\n\t * This is not utilized in absync internally.\n\t * @param eventName\n\t * @param data\n\t * @param callback\n\t */\n\tAbsyncService.prototype.emit = function AbsyncService$emit( eventName, data, callback ) {\n\t\tvar _absyncProvider = this.__absyncProvider;\n\n\t\tif( !_absyncProvider.ioSocket ) {\n\t\t\tthrow new Error( \"socket.io is not initialized.\" );\n\t\t}\n\n\t\tvar _rootScope = this.rootScope;\n\n\t\t_absyncProvider.__ioSocket.emit( eventName, data, function afterEmit() {\n\t\t\tvar args = arguments;\n\t\t\t_rootScope.$apply( function() {\n\t\t\t\tif( callback ) {\n\t\t\t\t\tcallback.apply( _absyncProvider.ioSocket, args );\n\t\t\t\t}\n\t\t\t} );\n\t\t} );\n\t};\n\n\t/**\n\t * Handle receiving an entity on the websocket connection.\n\t * @param eventName\n\t * @param callback\n\t * @param rootScope\n\t * @returns {Function}\n\t */\n\tAbsyncService.prototype.__handleEntityEvent = function AbsyncService$__handleEntityEvent( eventName, callback, rootScope ) {\n\t\tvar _absyncProvider = this.__absyncProvider;\n\n\t\tvar wrapper = function() {\n\t\t\tvar args = arguments;\n\t\t\trootScope.$apply( function() {\n\t\t\t\tcallback.apply( _absyncProvider.__ioSocket, args );\n\t\t\t} );\n\t\t};\n\t\t_absyncProvider.__ioSocket.on( eventName, wrapper );\n\n\t\t// Return a function that removes the listener.\n\t\t// TODO: This is not currently utilized due to the delayed listener registration approach.\n\t\treturn function removeListener() {\n\t\t\t_absyncProvider.__ioSocket.removeListener( eventName, wrapper );\n\t\t};\n\t};\n\n\t/**\n\t * This is a factory, which returns a absyncCacheServiceFactory.\n\t * The absyncCacheServiceFactory will then return the actual absyncCacheService.\n\t * @param name\n\t * @param configuration\n\t * @returns {absyncCacheServiceFactory}\n\t */\n\tfunction absyncCacheServiceFactoryFactory( name, configuration ) {\n\t\treturn absyncCacheServiceFactory;\n\n\t\t/* @ngInject */\n\t\tfunction absyncCacheServiceFactory( $http, $injector, $log, $q, $rootScope, absync ) {\n\t\t\tvar cacheService = this;\n\t\t\t$log.info( \"absync service for '\" + configuration.collectionName + \"' was instantiated.\" );\n\n\t\t\tvar _injector = configuration.injector || $injector;\n\t\t\tvar _injectorHasModel = _injector.has( configuration.model );\n\t\t\tif( !_injectorHasModel ) {\n\t\t\t\tthrow new Error( \"Unable to construct the '\" + name + \"' service, because the referenced model '\" + configuration.model + \"' is not available for injection.\" );\n\t\t\t}\n\t\t\tvar _model = _injector.get( configuration.model );\n\n\t\t\tvar serializeModel = _model.serialize || configuration.serialize || serializationNoop;\n\t\t\tvar deserializeModel = _model.deserialize || configuration.deserialize || serializationNoop;\n\n\t\t\tcacheService.name = configuration.collectionName;\n\n\t\t\tcacheService.entityCache = [];\n\t\t\tcacheService.entityCacheRaw = null;\n\n\t\t\tcacheService.dataAvailableDeferred = cacheService.dataAvailableDeferred || $q.defer();\n\t\t\tcacheService.objectsAvailableDeferred = cacheService.objectsAvailableDeferred || $q.defer();\n\t\t\tcacheService.dataAvailable = cacheService.dataAvailableDeferred.promise;\n\t\t\tcacheService.objectsAvailable = cacheService.objectsAvailableDeferred.promise;\n\n\t\t\tcacheService.httpInterface = $http;\n\t\t\tcacheService.serializer = serializeModel;\n\t\t\tcacheService.deserializer = deserializeModel;\n\n\t\t\tcacheService.ensureLoaded = function( forceReload ) {\n\t\t\t\tforceReload = (forceReload === true);\n\t\t\t\tif( null === cacheService.entityCacheRaw || forceReload ) {\n\t\t\t\t\tcacheService.entityCacheRaw = [];\n\n\t\t\t\t\tif( !configuration.collectionName || !configuration.collectionUri ) {\n\t\t\t\t\t\treturn $q( true )\n\t\t\t\t\t}\n\t\t\t\t\t$log.info( \"Retrieving '\" + configuration.collectionName + \"' collection…\" );\n\t\t\t\t\tcacheService.httpInterface.get( configuration.collectionUri )\n\t\t\t\t\t\t.then( function( peopleResult ) {\n\t\t\t\t\t\t\tcacheService.entityCacheRaw = peopleResult.data;\n\t\t\t\t\t\t\tcacheService.dataAvailableDeferred.resolve( peopleResult.data );\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfunction( error ) {\n\t\t\t\t\t\t\tcacheService.entityCacheRaw = null;\n\t\t\t\t\t\t\t$rootScope.$emit( \"authorizationError\", error );\n\t\t\t\t\t\t} );\n\t\t\t\t}\n\n\t\t\t\treturn $q.all( [ cacheService.dataAvailable,\n\t\t\t\t\tcacheService.objectsAvailable ] );\n\t\t\t};\n\n\t\t\tcacheService.dataAvailable\n\t\t\t\t.then( function( rawData ) {\n\t\t\t\t\tcacheService.entityCache = cacheService.entityCache || [];\n\t\t\t\t\trawData[ configuration.collectionName ].forEach( function( rawEntity ) {\n\t\t\t\t\t\tcacheService.entityCache.push( cacheService.deserializer( rawEntity ) );\n\t\t\t\t\t} );\n\t\t\t\t\tcacheService.objectsAvailableDeferred.resolve( cacheService.entityCache );\n\t\t\t\t\t$rootScope.$broadcast( \"collectionNew\", {\n\t\t\t\t\t\tservice : cacheService,\n\t\t\t\t\t\tcache   : cacheService.entityCache\n\t\t\t\t\t} );\n\t\t\t\t} );\n\n\t\t\t/**\n\t\t\t * Read a single entity from the cache, or load it from the server if required.\n\t\t\t * @param {String} id The ID of the entity to retrieve.\n\t\t\t * @returns {adapter.deferred.promise|*|defer.promise|eventObject.promise|promise|Q.promise}\n\t\t\t */\n\t\t\tcacheService.read = function( id ) {\n\t\t\t\tvar deferred = $q.defer();\n\n\t\t\t\t// Check if the entity is in the cache and return instantly if found.\n\t\t\t\tfor( var entityIndex = 0, entity = cacheService.entityCache[ 0 ], cacheSize = cacheService.entityCache.length;\n\t\t\t\t     entityIndex < cacheSize;\n\t\t\t\t     ++entityIndex, entity = cacheService.entityCache[ entityIndex ] ) {\n\t\t\t\t\tif( entity.id == id ) {\n\t\t\t\t\t\tdeferred.resolve( entity );\n\t\t\t\t\t\treturn deferred.promise;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Grab the entity from the backend.\n\t\t\t\tcacheService.httpInterface.get( configuration.entityUri + \"/\" + id ).success( onEntityRetrieved );\n\t\t\t\tfunction onEntityRetrieved( data ) {\n\t\t\t\t\tif( !data[ configuration.entityName ] ) {\n\t\t\t\t\t\tdeferred.reject( new Error( \"The requested entity could not be found in the database.\" ) );\n\t\t\t\t\t\treturn deferred.promise;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar entity = cacheService.deserializer( data[ configuration.entityName ] );\n\t\t\t\t\tupdateCacheWithEntity( entity );\n\t\t\t\t\tdeferred.resolve( entity );\n\t\t\t\t}\n\n\t\t\t\treturn deferred.promise;\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * Updates an entity and persists it to the backend and the cache.\n\t\t\t * @param {Object} entity\n\t\t\t */\n\t\t\tcacheService.update = function( entity ) {\n\t\t\t\tvar promise;\n\n\t\t\t\tvar reduced = cacheService.reduceComplex( entity );\n\t\t\t\tvar serialized = cacheService.serializer( reduced );\n\n\t\t\t\t// Wrap entity in a new object, with a single property, named after the entity type.\n\t\t\t\tvar wrapper = {};\n\t\t\t\twrapper[ configuration.entityName ] = serialized;\n\n\t\t\t\tif( \"undefined\" !== typeof( entity.id ) ) {\n\t\t\t\t\tpromise = cacheService.httpInterface.put( configuration.entityUri + \"/\" + entity.id, wrapper );\n\t\t\t\t\tpromise\n\t\t\t\t\t\t.then( function( result ) {\n\t\t\t\t\t\t\t// Writing an entity to the backend will usually invoke an update event to be\n\t\t\t\t\t\t\t// broadcast over websockets, where would also retrieve the updated record.\n\t\t\t\t\t\t\t// We still put the updated record we receive here into the cache to ensure early consistency.\n\t\t\t\t\t\t\tif( result.data[ configuration.entityName ] ) {\n\t\t\t\t\t\t\t\tvar newEntity = cacheService.deserializer( result.data[ configuration.entityName ] );\n\t\t\t\t\t\t\t\tupdateCacheWithEntity( newEntity );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfunction( error ) {\n\t\t\t\t\t\t\t$log.error( error );\n\t\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\t\t\t\t\t// Create a new entity\n\t\t\t\t\tpromise = cacheService.httpInterface.post( configuration.collectionUri, wrapper );\n\t\t\t\t\tpromise\n\t\t\t\t\t\t.then( function( result ) {\n\t\t\t\t\t\t\t// Writing an entity to the backend will usually invoke an update event to be\n\t\t\t\t\t\t\t// broadcast over websockets, where would also retrieve the updated record.\n\t\t\t\t\t\t\t// We still put the updated record we receive here into the cache to ensure early consistency.\n\t\t\t\t\t\t\tif( result.data[ configuration.entityName ] ) {\n\t\t\t\t\t\t\t\tvar newEntity = cacheService.deserializer( result.data[ configuration.entityName ] );\n\t\t\t\t\t\t\t\tupdateCacheWithEntity( newEntity );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfunction( error ) {\n\t\t\t\t\t\t\t$log.error( error );\n\t\t\t\t\t\t} );\n\t\t\t\t}\n\n\t\t\t\treturn promise;\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * Creates a new entity and persists it to the backend and the cache.\n\t\t\t */\n\t\t\tcacheService.create = cacheService.update;\n\n\t\t\t/**\n\t\t\t * Remove an entity from the cache and have it deleted on the backend.\n\t\t\t * @param {Object} entity\n\t\t\t */\n\t\t\tcacheService.delete = function( entity ) {\n\t\t\t\tvar deferred = $q.defer();\n\n\t\t\t\tvar entityId = entity.id;\n\t\t\t\tcacheService.httpInterface.delete( configuration.entityUri + \"/\" + entityId )\n\t\t\t\t\t.success( function( data, status, headers, config ) {\n\t\t\t\t\t\tremoveEntityFromCache( entityId );\n\t\t\t\t\t\tdeferred.resolve();\n\t\t\t\t\t} )\n\t\t\t\t\t.error( function( data, status, headers, config ) {\n\t\t\t\t\t\t$log.error( data );\n\t\t\t\t\t\tdeferred.reject( new Error( \"Unable to delete entity.\" ) );\n\t\t\t\t\t} );\n\n\t\t\t\treturn deferred.promise;\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * Put an entity into the cache or update the existing record if the entity was already in the cache.\n\t\t\t * @param {Object} entityToCache\n\t\t\t */\n\t\t\tfunction updateCacheWithEntity( entityToCache ) {\n\t\t\t\t$log.info( \"Updating entity in cache...\" );\n\t\t\t\tvar found = false;\n\t\t\t\tfor( var entityIndex = 0, entity = cacheService.entityCache[ 0 ], cacheSize = cacheService.entityCache.length;\n\t\t\t\t     entityIndex < cacheSize;\n\t\t\t\t     ++entityIndex, entity = cacheService.entityCache[ entityIndex ] ) {\n\t\t\t\t\tif( entity.id == entityToCache.id ) {\n\t\t\t\t\t\t$rootScope.$broadcast( \"beforeEntityUpdated\",\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tservice : cacheService,\n\t\t\t\t\t\t\t\tcache   : cacheService.entityCache,\n\t\t\t\t\t\t\t\tentity  : cacheService.entityCache[ entityIndex ],\n\t\t\t\t\t\t\t\tupdated : entityToCache\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t// Use the \"copyFrom\" method on the entity, if it exists, otherwise use naive approach.\n\t\t\t\t\t\tvar targetEntity = cacheService.entityCache[ entityIndex ];\n\t\t\t\t\t\tif( targetEntity.copyFrom ) {\n\t\t\t\t\t\t\ttargetEntity.copyFrom( entityToCache );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tangular.extend( targetEntity, entityToCache );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t$rootScope.$broadcast( \"entityUpdated\",\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tservice : cacheService,\n\t\t\t\t\t\t\t\tcache   : cacheService.entityCache,\n\t\t\t\t\t\t\t\tentity  : cacheService.entityCache[ entityIndex ]\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// If the entity wasn't found in our records, it's a new entity.\n\t\t\t\tif( !found ) {\n\t\t\t\t\tcacheService.entityCache.push( entityToCache );\n\t\t\t\t\t$rootScope.$broadcast( \"entityNew\", {\n\t\t\t\t\t\tservice : cacheService,\n\t\t\t\t\t\tcache   : cacheService.entityCache,\n\t\t\t\t\t\tentity  : entityToCache\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Removes an entity from the internal cache. The entity is not removed from the backend.\n\t\t\t * @param {String} id The ID of the entity to remove from the cache.\n\t\t\t */\n\t\t\tfunction removeEntityFromCache( id ) {\n\t\t\t\tfor( var entityIndex = 0, entity = cacheService.entityCache[ 0 ], cacheSize = cacheService.entityCache.length;\n\t\t\t\t     entityIndex < cacheSize;\n\t\t\t\t     ++entityIndex, entity = cacheService.entityCache[ entityIndex ] ) {\n\t\t\t\t\tif( entity.id == id ) {\n\t\t\t\t\t\t$rootScope.$broadcast( \"beforeEntityRemoved\", {\n\t\t\t\t\t\t\tservice : cacheService,\n\t\t\t\t\t\t\tcache   : cacheService.entityCache,\n\t\t\t\t\t\t\tentity  : entity\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tcacheService.entityCache.splice( entityIndex, 1 );\n\t\t\t\t\t\t$rootScope.$broadcast( \"entityRemoved\", {\n\t\t\t\t\t\t\tservice : cacheService,\n\t\t\t\t\t\t\tcache   : cacheService.entityCache,\n\t\t\t\t\t\t\tentity  : entity\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Retrieve an associative array of all cached entities, which uses the ID of the entity records as the key in the array.\n\t\t\t * @returns {Array}\n\t\t\t */\n\t\t\tcacheService.lookupTableById = function() {\n\t\t\t\t//TODO: Keep a copy of the lookup table and only update it when the cached data updates\n\t\t\t\tvar lookupTable = [];\n\t\t\t\tfor( var entityIndex = 0, cacheSize = cacheService.entityCache.length; entityIndex < cacheSize; ++entityIndex ) {\n\t\t\t\t\tlookupTable[ cacheService.entityCache[ entityIndex ].id ] = cacheService.entityCache[ entityIndex ];\n\t\t\t\t}\n\t\t\t\treturn lookupTable;\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * Reduce instances of complex types within an entity with their respective IDs.\n\t\t\t * Note that no type checks are being performed. Every nested object with an \"id\" property is treated as a complex type.\n\t\t\t * @param {Object} entity The entity that should have its complex member reduced.\n\t\t\t * @param {Boolean} [arrayInsteadOfObject=false] true if the manipulated entity is an array; false if it's an object.\n\t\t\t * @returns {Object|Array} A copy of the input entity, with complex type instances replaced with their respective ID.\n\t\t\t */\n\t\t\tcacheService.reduceComplex = function( entity, arrayInsteadOfObject ) {\n\t\t\t\tvar result = arrayInsteadOfObject ? [] : {};\n\t\t\t\tfor( var propertyName in entity ) {\n\t\t\t\t\tif( !entity.hasOwnProperty( propertyName ) ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Recurse for nested arrays.\n\t\t\t\t\tif( Array.isArray( entity[ propertyName ] ) ) {\n\t\t\t\t\t\tresult[ propertyName ] = cacheService.reduceComplex( entity[ propertyName ], true );\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Replace complex type with its ID.\n\t\t\t\t\tif( entity[ propertyName ] && entity[ propertyName ].id ) {\n\t\t\t\t\t\tresult[ propertyName ] = entity[ propertyName ].id;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Just copy over the plain property.\n\t\t\t\t\tresult[ propertyName ] = entity[ propertyName ];\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * Populate references to complex types in an instance.\n\t\t\t * @param {Object} entity The entity that should be manipulated.\n\t\t\t * @param {String} propertyName The name of the property of entity which should be populated.\n\t\t\t * @param {Object} cache An instance of another caching service that can provide the complex\n\t\t\t * type instances which are being referenced in entity.\n\t\t\t * @param {Boolean} [force=false] If true, all complex types will be replaced with references to the\n\t\t\t * instances in cache; otherwise, only properties that are string representations of complex type IDs will be replaced.\n\t\t\t * @returns {Promise}\n\t\t\t */\n\t\t\tcacheService.populateComplex = function( entity, propertyName, cache, force ) {\n\t\t\t\t// If the target property is an array, ...\n\t\t\t\tif( Array.isArray( entity[ propertyName ] ) ) {\n\t\t\t\t\t// ...map the elements in the array to promises.\n\t\t\t\t\tvar promises = entity[ propertyName ].map( function mapElementToPromise( element, index ) {\n\t\t\t\t\t\t// We usually assume the properties to be strings (the ID of the referenced complex).\n\t\t\t\t\t\tif( typeof entity[ propertyName ][ index ] !== \"string\" ) {\n\t\t\t\t\t\t\t// If \"force\" is enabled, we check if this non-string property is an object and has an \"id\" member, which is a string.\n\t\t\t\t\t\t\tif( force && typeof entity[ propertyName ][ index ] === \"object\" && typeof entity[ propertyName ][ index ].id === \"string\" ) {\n\t\t\t\t\t\t\t\t// If that is true, then we replace the whole object with the ID and continue as usual.\n\t\t\t\t\t\t\t\tentity[ propertyName ][ index ] = entity[ propertyName ][ index ].id;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn $q.when( false );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Treat the property as an ID and read the complex with that ID from the cache.\n\t\t\t\t\t\treturn cache.read( entity[ propertyName ][ index ] )\n\t\t\t\t\t\t\t.then( function onComplexRetrieved( complex ) {\n\t\t\t\t\t\t\t\t// When the complex was retrieved, store it back into the array.\n\t\t\t\t\t\t\t\tentity[ propertyName ][ index ] = complex;\n\t\t\t\t\t\t\t} )\n\t\t\t\t\t} );\n\n\t\t\t\t\treturn $q.all( promises );\n\t\t\t\t} else {\n\t\t\t\t\t// We usually assume the properties to be strings (the ID of the referenced complex).\n\t\t\t\t\tif( typeof entity[ propertyName ] !== \"string\" ) {\n\t\t\t\t\t\t// If \"force\" is enabled, we check if this non-string property is an object and has an \"id\" member, which is a string.\n\t\t\t\t\t\tif( force && typeof entity[ propertyName ] === \"object\" && typeof entity[ propertyName ].id === \"string\" ) {\n\t\t\t\t\t\t\t// If that is true, then we replace the whole object with the ID and continue as usual.\n\t\t\t\t\t\t\tentity[ propertyName ] = entity[ propertyName ].id;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn $q.when( false );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Treat the property as an ID and read the complex with that ID from the cache.\n\t\t\t\t\treturn cache.read( entity[ propertyName ] )\n\t\t\t\t\t\t.then( function onComplexRetrieved( complex ) {\n\t\t\t\t\t\t\t// When the complex was retrieved, store it back into the entity.\n\t\t\t\t\t\t\tentity[ propertyName ] = complex;\n\t\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// Listen for entity broadcasts. These are sent when a record is received through a websocket.\n\t\t\t$rootScope.$on( configuration.entityName, function( event, args ) {\n\t\t\t\tvar entityReceived = args;\n\n\t\t\t\t// Determine if the received record consists ONLY of an id property,\n\t\t\t\t// which would mean that this record was deleted from the backend.\n\t\t\t\tif( 1 == Object.keys( entityReceived ).length && entityReceived.hasOwnProperty( \"id\" ) ) {\n\t\t\t\t\t$log.info( \"Entity was deleted from the server. Updating cache...\" );\n\t\t\t\t\tremoveEntityFromCache( entityReceived.id );\n\t\t\t\t} else {\n\t\t\t\t\tupdateCacheWithEntity( cacheService.deserializer( entityReceived ) );\n\t\t\t\t}\n\t\t\t} );\n\t\t\t$rootScope.$on( configuration.collectionName, function( event, args ) {\n\t\t\t\tvar collectionReceived = args;\n\n\t\t\t\t// Clear current cache before importing collection\n\t\t\t\twhile( 0 < cacheService.entityCache.length ) {\n\t\t\t\t\tcacheService.entityCache.pop();\n\t\t\t\t}\n\n\t\t\t\tcollectionReceived.forEach( function addEntityToCache( entityReceived ) {\n\t\t\t\t\tupdateCacheWithEntity( cacheService.deserializer( entityReceived ) );\n\t\t\t\t} );\n\t\t\t} );\n\n\n\t\t\tabsync.on( configuration.entityName, function( message ) {\n\t\t\t\t$rootScope.$broadcast( configuration.entityName, message[ configuration.entityName ] );\n\t\t\t} );\n\t\t\tabsync.on( configuration.collectionName, function( message ) {\n\t\t\t\t$rootScope.$broadcast( configuration.collectionName, message[ configuration.collectionName ] );\n\t\t\t} );\n\n\t\t\treturn cacheService;\n\t\t}\n\t}\n\n\tfunction serializationNoop( model ) {\n\t\treturn model;\n\t}\n\n}());\n","(function() {\n\t\"use strict\";\n\n\tangular.module( \"absync\", [\n\t] );\n})();\n;(function( undefined ) {\n\t\"use strict\";\n\n\t/**\n\t * Please make note of the following variable naming conventions:\n\t * 1. Function-scope local variables must be prefixed with a single underscore.\n\t *    This indicates a temporary variable.\n\t * 2. Variables that are persisted onto publicly accessible entities must be prefixed with two underscores.\n\t *    This indicates a private variable.\n\t *    Hiding private variables, by using closures, is discouraged.\n\t */\n\n\tangular\n\t\t.module( \"absync\" )\n\t\t.provider( \"absync\", getAbsyncProvider );\n\n\t/* @ngInject */\n\tfunction getAbsyncProvider( $injector, $provide ) {\n\t\tvar _absyncProvider = this;\n\n\t\t_absyncProvider.__ioSocket = null;\n\t\t// If socket.io was not connected when a service was constructed, we put the registration request\n\t\t// into this array and register it as soon as socket.io is configured.\n\t\t_absyncProvider.__registerLater = [];\n\n\t\t// The collections that absync provides.\n\t\t_absyncProvider.__collections = {};\n\n\t\t// Register the configurator on the provider itself to allow early configuration during setup phase.\n\t\t_absyncProvider.configure = function AbsyncProvider$configure( configuration ) {\n\t\t\tvar socket = configuration.socket || configuration;\n\t\t\tif( typeof socket == \"function\" ) {\n\t\t\t\t// Assume io\n\t\t\t\t_absyncProvider.__ioSocket = socket();\n\n\t\t\t} else if( io && io.Socket && socket instanceof io.Socket ) {\n\t\t\t\t// Assume io.Socket\n\t\t\t\t_absyncProvider.__ioSocket = socket;\n\n\t\t\t} else {\n\t\t\t\tthrow new Error( \"configure() expects input to be a function or a socket.io Socket instance.\" );\n\t\t\t}\n\n\t\t\t// Check if services already tried to register listeners, if so, register them now.\n\t\t\tif( _absyncProvider.__registerLater.length ) {\n\t\t\t\tangular.forEach( _absyncProvider.__registerLater, function registerListener( listener ) {\n\t\t\t\t\tthis.__handleEntityEvent( listener.eventName, listener.callback, listener.rootScope );\n\t\t\t\t} );\n\t\t\t\t_absyncProvider.__registerLater = [];\n\t\t\t}\n\t\t};\n\n\t\t// Request a new synchronized collection.\n\t\t// This only registers the intent to use that collection. It will be constructed when it is first used.\n\t\t_absyncProvider.collection = function AbsyncProvider$collection( name, configuration ) {\n\t\t\tif( _absyncProvider.__collections[ name ] ) {\n\t\t\t\tthrow new Error( \"A collection with the name '\" + name + \"' was already requested. Names for collections must be unique.\" );\n\t\t\t}\n\n\t\t\t// Register the service configuration.\n\t\t\t_absyncProvider.__collections[ name ] = absyncCacheServiceFactoryFactory( name, configuration );\n\n\t\t\t// Register the new service.\n\t\t\t$provide\n\t\t\t\t.factory( name, _absyncProvider.__collections[ name ] );\n\t\t};\n\n\t\t// Register the service factory.\n\t\t/* @ngInject */\n\t\t_absyncProvider.$get = function absyncProvider$$get( $rootScope ) {\n\t\t\treturn new AbsyncService( this, $rootScope );\n\t\t};\r\n\t\t_absyncProvider.$get.$inject = [\"$rootScope\"];\n\t}\r\n\tgetAbsyncProvider.$inject = [\"$injector\", \"$provide\"];\n\n\t/**\n\t * The service that is received when injecting \"absync\".\n\t * This service is primarily used internally to set up the connection between socket.io and the individual\n\t * caching services.\n\t * @param {Object} parentProvider The AbsyncProvider that provides this service.\n\t * @param {Object} rootScope The Angular root scope.\n\t * @constructor\n\t */\n\tfunction AbsyncService( parentProvider, rootScope ) {\n\t\tthis.__absyncProvider = parentProvider;\n\t\tthis.__rootScope = rootScope;\n\t}\n\n\t/**\n\t * Configure the socket.io connection for absync.\n\t * @param configuration\n\t */\n\tAbsyncService.prototype.configure = function AbsyncService$configure( configuration ) {\n\t\tvar _absyncProvider = this.__absyncProvider;\n\t\t_absyncProvider.configure( configuration );\n\t};\n\n\t/**\n\t * Register an event listener that is called when a specific entity is received on the websocket.\n\t * @param eventName\n\t * @param callback\n\t */\n\tAbsyncService.prototype.on = function AbsyncService$on( eventName, callback ) {\n\t\tvar _absyncProvider = this.__absyncProvider;\n\t\tvar _absyncService = this;\n\n\t\tif( !_absyncProvider.__ioSocket ) {\n\t\t\t_absyncProvider.__registerLater.push( {\n\t\t\t\teventName : eventName,\n\t\t\t\tcallback  : callback,\n\t\t\t\trootScope : _absyncProvider.__rootScope\n\t\t\t} );\n\t\t\treturn;\n\t\t}\n\n\t\tthis.__handleEntityEvent( eventName, callback, _absyncService.__rootScope );\n\t};\n\n\t/**\n\t * Convenience method to allow the user to emit() from the websocket.\n\t * This is not utilized in absync internally.\n\t * @param eventName\n\t * @param data\n\t * @param callback\n\t */\n\tAbsyncService.prototype.emit = function AbsyncService$emit( eventName, data, callback ) {\n\t\tvar _absyncProvider = this.__absyncProvider;\n\n\t\tif( !_absyncProvider.ioSocket ) {\n\t\t\tthrow new Error( \"socket.io is not initialized.\" );\n\t\t}\n\n\t\tvar _rootScope = this.rootScope;\n\n\t\t_absyncProvider.__ioSocket.emit( eventName, data, function afterEmit() {\n\t\t\tvar args = arguments;\n\t\t\t_rootScope.$apply( function() {\n\t\t\t\tif( callback ) {\n\t\t\t\t\tcallback.apply( _absyncProvider.ioSocket, args );\n\t\t\t\t}\n\t\t\t} );\n\t\t} );\n\t};\n\n\t/**\n\t * Handle receiving an entity on the websocket connection.\n\t * @param eventName\n\t * @param callback\n\t * @param rootScope\n\t * @returns {Function}\n\t */\n\tAbsyncService.prototype.__handleEntityEvent = function AbsyncService$__handleEntityEvent( eventName, callback, rootScope ) {\n\t\tvar _absyncProvider = this.__absyncProvider;\n\n\t\tvar wrapper = function() {\n\t\t\tvar args = arguments;\n\t\t\trootScope.$apply( function() {\n\t\t\t\tcallback.apply( _absyncProvider.__ioSocket, args );\n\t\t\t} );\n\t\t};\n\t\t_absyncProvider.__ioSocket.on( eventName, wrapper );\n\n\t\t// Return a function that removes the listener.\n\t\t// TODO: This is not currently utilized due to the delayed listener registration approach.\n\t\treturn function removeListener() {\n\t\t\t_absyncProvider.__ioSocket.removeListener( eventName, wrapper );\n\t\t};\n\t};\n\n\t/**\n\t * This is a factory, which returns a absyncCacheServiceFactory.\n\t * The absyncCacheServiceFactory will then return the actual absyncCacheService.\n\t * @param name\n\t * @param configuration\n\t * @returns {absyncCacheServiceFactory}\n\t */\n\tfunction absyncCacheServiceFactoryFactory( name, configuration ) {\r\n\t\tabsyncCacheServiceFactory.$inject = [\"$http\", \"$injector\", \"$log\", \"$q\", \"$rootScope\", \"absync\"];\n\t\treturn absyncCacheServiceFactory;\n\n\t\t/* @ngInject */\n\t\tfunction absyncCacheServiceFactory( $http, $injector, $log, $q, $rootScope, absync ) {\n\t\t\tvar cacheService = this;\n\t\t\t$log.info( \"absync service for '\" + configuration.collectionName + \"' was instantiated.\" );\n\n\t\t\tvar _injector = configuration.injector || $injector;\n\t\t\tvar _injectorHasModel = _injector.has( configuration.model );\n\t\t\tif( !_injectorHasModel ) {\n\t\t\t\tthrow new Error( \"Unable to construct the '\" + name + \"' service, because the referenced model '\" + configuration.model + \"' is not available for injection.\" );\n\t\t\t}\n\t\t\tvar _model = _injector.get( configuration.model );\n\n\t\t\tvar serializeModel = _model.serialize || configuration.serialize || serializationNoop;\n\t\t\tvar deserializeModel = _model.deserialize || configuration.deserialize || serializationNoop;\n\n\t\t\tcacheService.name = configuration.collectionName;\n\n\t\t\tcacheService.entityCache = [];\n\t\t\tcacheService.entityCacheRaw = null;\n\n\t\t\tcacheService.dataAvailableDeferred = cacheService.dataAvailableDeferred || $q.defer();\n\t\t\tcacheService.objectsAvailableDeferred = cacheService.objectsAvailableDeferred || $q.defer();\n\t\t\tcacheService.dataAvailable = cacheService.dataAvailableDeferred.promise;\n\t\t\tcacheService.objectsAvailable = cacheService.objectsAvailableDeferred.promise;\n\n\t\t\tcacheService.httpInterface = $http;\n\t\t\tcacheService.serializer = serializeModel;\n\t\t\tcacheService.deserializer = deserializeModel;\n\n\t\t\tcacheService.ensureLoaded = function( forceReload ) {\n\t\t\t\tforceReload = (forceReload === true);\n\t\t\t\tif( null === cacheService.entityCacheRaw || forceReload ) {\n\t\t\t\t\tcacheService.entityCacheRaw = [];\n\n\t\t\t\t\tif( !configuration.collectionName || !configuration.collectionUri ) {\n\t\t\t\t\t\treturn $q( true )\n\t\t\t\t\t}\n\t\t\t\t\t$log.info( \"Retrieving '\" + configuration.collectionName + \"' collection…\" );\n\t\t\t\t\tcacheService.httpInterface.get( configuration.collectionUri )\n\t\t\t\t\t\t.then( function( peopleResult ) {\n\t\t\t\t\t\t\tcacheService.entityCacheRaw = peopleResult.data;\n\t\t\t\t\t\t\tcacheService.dataAvailableDeferred.resolve( peopleResult.data );\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfunction( error ) {\n\t\t\t\t\t\t\tcacheService.entityCacheRaw = null;\n\t\t\t\t\t\t\t$rootScope.$emit( \"authorizationError\", error );\n\t\t\t\t\t\t} );\n\t\t\t\t}\n\n\t\t\t\treturn $q.all( [ cacheService.dataAvailable,\n\t\t\t\t\tcacheService.objectsAvailable ] );\n\t\t\t};\n\n\t\t\tcacheService.dataAvailable\n\t\t\t\t.then( function( rawData ) {\n\t\t\t\t\tcacheService.entityCache = cacheService.entityCache || [];\n\t\t\t\t\trawData[ configuration.collectionName ].forEach( function( rawEntity ) {\n\t\t\t\t\t\tcacheService.entityCache.push( cacheService.deserializer( rawEntity ) );\n\t\t\t\t\t} );\n\t\t\t\t\tcacheService.objectsAvailableDeferred.resolve( cacheService.entityCache );\n\t\t\t\t\t$rootScope.$broadcast( \"collectionNew\", {\n\t\t\t\t\t\tservice : cacheService,\n\t\t\t\t\t\tcache   : cacheService.entityCache\n\t\t\t\t\t} );\n\t\t\t\t} );\n\n\t\t\t/**\n\t\t\t * Read a single entity from the cache, or load it from the server if required.\n\t\t\t * @param {String} id The ID of the entity to retrieve.\n\t\t\t * @returns {adapter.deferred.promise|*|defer.promise|eventObject.promise|promise|Q.promise}\n\t\t\t */\n\t\t\tcacheService.read = function( id ) {\n\t\t\t\tvar deferred = $q.defer();\n\n\t\t\t\t// Check if the entity is in the cache and return instantly if found.\n\t\t\t\tfor( var entityIndex = 0, entity = cacheService.entityCache[ 0 ], cacheSize = cacheService.entityCache.length;\n\t\t\t\t     entityIndex < cacheSize;\n\t\t\t\t     ++entityIndex, entity = cacheService.entityCache[ entityIndex ] ) {\n\t\t\t\t\tif( entity.id == id ) {\n\t\t\t\t\t\tdeferred.resolve( entity );\n\t\t\t\t\t\treturn deferred.promise;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Grab the entity from the backend.\n\t\t\t\tcacheService.httpInterface.get( configuration.entityUri + \"/\" + id ).success( onEntityRetrieved );\n\t\t\t\tfunction onEntityRetrieved( data ) {\n\t\t\t\t\tif( !data[ configuration.entityName ] ) {\n\t\t\t\t\t\tdeferred.reject( new Error( \"The requested entity could not be found in the database.\" ) );\n\t\t\t\t\t\treturn deferred.promise;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar entity = cacheService.deserializer( data[ configuration.entityName ] );\n\t\t\t\t\tupdateCacheWithEntity( entity );\n\t\t\t\t\tdeferred.resolve( entity );\n\t\t\t\t}\n\n\t\t\t\treturn deferred.promise;\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * Updates an entity and persists it to the backend and the cache.\n\t\t\t * @param {Object} entity\n\t\t\t */\n\t\t\tcacheService.update = function( entity ) {\n\t\t\t\tvar promise;\n\n\t\t\t\tvar reduced = cacheService.reduceComplex( entity );\n\t\t\t\tvar serialized = cacheService.serializer( reduced );\n\n\t\t\t\t// Wrap entity in a new object, with a single property, named after the entity type.\n\t\t\t\tvar wrapper = {};\n\t\t\t\twrapper[ configuration.entityName ] = serialized;\n\n\t\t\t\tif( \"undefined\" !== typeof( entity.id ) ) {\n\t\t\t\t\tpromise = cacheService.httpInterface.put( configuration.entityUri + \"/\" + entity.id, wrapper );\n\t\t\t\t\tpromise\n\t\t\t\t\t\t.then( function( result ) {\n\t\t\t\t\t\t\t// Writing an entity to the backend will usually invoke an update event to be\n\t\t\t\t\t\t\t// broadcast over websockets, where would also retrieve the updated record.\n\t\t\t\t\t\t\t// We still put the updated record we receive here into the cache to ensure early consistency.\n\t\t\t\t\t\t\tif( result.data[ configuration.entityName ] ) {\n\t\t\t\t\t\t\t\tvar newEntity = cacheService.deserializer( result.data[ configuration.entityName ] );\n\t\t\t\t\t\t\t\tupdateCacheWithEntity( newEntity );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfunction( error ) {\n\t\t\t\t\t\t\t$log.error( error );\n\t\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\t\t\t\t\t// Create a new entity\n\t\t\t\t\tpromise = cacheService.httpInterface.post( configuration.collectionUri, wrapper );\n\t\t\t\t\tpromise\n\t\t\t\t\t\t.then( function( result ) {\n\t\t\t\t\t\t\t// Writing an entity to the backend will usually invoke an update event to be\n\t\t\t\t\t\t\t// broadcast over websockets, where would also retrieve the updated record.\n\t\t\t\t\t\t\t// We still put the updated record we receive here into the cache to ensure early consistency.\n\t\t\t\t\t\t\tif( result.data[ configuration.entityName ] ) {\n\t\t\t\t\t\t\t\tvar newEntity = cacheService.deserializer( result.data[ configuration.entityName ] );\n\t\t\t\t\t\t\t\tupdateCacheWithEntity( newEntity );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfunction( error ) {\n\t\t\t\t\t\t\t$log.error( error );\n\t\t\t\t\t\t} );\n\t\t\t\t}\n\n\t\t\t\treturn promise;\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * Creates a new entity and persists it to the backend and the cache.\n\t\t\t */\n\t\t\tcacheService.create = cacheService.update;\n\n\t\t\t/**\n\t\t\t * Remove an entity from the cache and have it deleted on the backend.\n\t\t\t * @param {Object} entity\n\t\t\t */\n\t\t\tcacheService.delete = function( entity ) {\n\t\t\t\tvar deferred = $q.defer();\n\n\t\t\t\tvar entityId = entity.id;\n\t\t\t\tcacheService.httpInterface.delete( configuration.entityUri + \"/\" + entityId )\n\t\t\t\t\t.success( function( data, status, headers, config ) {\n\t\t\t\t\t\tremoveEntityFromCache( entityId );\n\t\t\t\t\t\tdeferred.resolve();\n\t\t\t\t\t} )\n\t\t\t\t\t.error( function( data, status, headers, config ) {\n\t\t\t\t\t\t$log.error( data );\n\t\t\t\t\t\tdeferred.reject( new Error( \"Unable to delete entity.\" ) );\n\t\t\t\t\t} );\n\n\t\t\t\treturn deferred.promise;\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * Put an entity into the cache or update the existing record if the entity was already in the cache.\n\t\t\t * @param {Object} entityToCache\n\t\t\t */\n\t\t\tfunction updateCacheWithEntity( entityToCache ) {\n\t\t\t\t$log.info( \"Updating entity in cache...\" );\n\t\t\t\tvar found = false;\n\t\t\t\tfor( var entityIndex = 0, entity = cacheService.entityCache[ 0 ], cacheSize = cacheService.entityCache.length;\n\t\t\t\t     entityIndex < cacheSize;\n\t\t\t\t     ++entityIndex, entity = cacheService.entityCache[ entityIndex ] ) {\n\t\t\t\t\tif( entity.id == entityToCache.id ) {\n\t\t\t\t\t\t$rootScope.$broadcast( \"beforeEntityUpdated\",\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tservice : cacheService,\n\t\t\t\t\t\t\t\tcache   : cacheService.entityCache,\n\t\t\t\t\t\t\t\tentity  : cacheService.entityCache[ entityIndex ],\n\t\t\t\t\t\t\t\tupdated : entityToCache\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t// Use the \"copyFrom\" method on the entity, if it exists, otherwise use naive approach.\n\t\t\t\t\t\tvar targetEntity = cacheService.entityCache[ entityIndex ];\n\t\t\t\t\t\tif( targetEntity.copyFrom ) {\n\t\t\t\t\t\t\ttargetEntity.copyFrom( entityToCache );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tangular.extend( targetEntity, entityToCache );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t$rootScope.$broadcast( \"entityUpdated\",\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tservice : cacheService,\n\t\t\t\t\t\t\t\tcache   : cacheService.entityCache,\n\t\t\t\t\t\t\t\tentity  : cacheService.entityCache[ entityIndex ]\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// If the entity wasn't found in our records, it's a new entity.\n\t\t\t\tif( !found ) {\n\t\t\t\t\tcacheService.entityCache.push( entityToCache );\n\t\t\t\t\t$rootScope.$broadcast( \"entityNew\", {\n\t\t\t\t\t\tservice : cacheService,\n\t\t\t\t\t\tcache   : cacheService.entityCache,\n\t\t\t\t\t\tentity  : entityToCache\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Removes an entity from the internal cache. The entity is not removed from the backend.\n\t\t\t * @param {String} id The ID of the entity to remove from the cache.\n\t\t\t */\n\t\t\tfunction removeEntityFromCache( id ) {\n\t\t\t\tfor( var entityIndex = 0, entity = cacheService.entityCache[ 0 ], cacheSize = cacheService.entityCache.length;\n\t\t\t\t     entityIndex < cacheSize;\n\t\t\t\t     ++entityIndex, entity = cacheService.entityCache[ entityIndex ] ) {\n\t\t\t\t\tif( entity.id == id ) {\n\t\t\t\t\t\t$rootScope.$broadcast( \"beforeEntityRemoved\", {\n\t\t\t\t\t\t\tservice : cacheService,\n\t\t\t\t\t\t\tcache   : cacheService.entityCache,\n\t\t\t\t\t\t\tentity  : entity\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tcacheService.entityCache.splice( entityIndex, 1 );\n\t\t\t\t\t\t$rootScope.$broadcast( \"entityRemoved\", {\n\t\t\t\t\t\t\tservice : cacheService,\n\t\t\t\t\t\t\tcache   : cacheService.entityCache,\n\t\t\t\t\t\t\tentity  : entity\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Retrieve an associative array of all cached entities, which uses the ID of the entity records as the key in the array.\n\t\t\t * @returns {Array}\n\t\t\t */\n\t\t\tcacheService.lookupTableById = function() {\n\t\t\t\t//TODO: Keep a copy of the lookup table and only update it when the cached data updates\n\t\t\t\tvar lookupTable = [];\n\t\t\t\tfor( var entityIndex = 0, cacheSize = cacheService.entityCache.length; entityIndex < cacheSize; ++entityIndex ) {\n\t\t\t\t\tlookupTable[ cacheService.entityCache[ entityIndex ].id ] = cacheService.entityCache[ entityIndex ];\n\t\t\t\t}\n\t\t\t\treturn lookupTable;\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * Reduce instances of complex types within an entity with their respective IDs.\n\t\t\t * Note that no type checks are being performed. Every nested object with an \"id\" property is treated as a complex type.\n\t\t\t * @param {Object} entity The entity that should have its complex member reduced.\n\t\t\t * @param {Boolean} [arrayInsteadOfObject=false] true if the manipulated entity is an array; false if it's an object.\n\t\t\t * @returns {Object|Array} A copy of the input entity, with complex type instances replaced with their respective ID.\n\t\t\t */\n\t\t\tcacheService.reduceComplex = function( entity, arrayInsteadOfObject ) {\n\t\t\t\tvar result = arrayInsteadOfObject ? [] : {};\n\t\t\t\tfor( var propertyName in entity ) {\n\t\t\t\t\tif( !entity.hasOwnProperty( propertyName ) ) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Recurse for nested arrays.\n\t\t\t\t\tif( Array.isArray( entity[ propertyName ] ) ) {\n\t\t\t\t\t\tresult[ propertyName ] = cacheService.reduceComplex( entity[ propertyName ], true );\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Replace complex type with its ID.\n\t\t\t\t\tif( entity[ propertyName ] && entity[ propertyName ].id ) {\n\t\t\t\t\t\tresult[ propertyName ] = entity[ propertyName ].id;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Just copy over the plain property.\n\t\t\t\t\tresult[ propertyName ] = entity[ propertyName ];\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * Populate references to complex types in an instance.\n\t\t\t * @param {Object} entity The entity that should be manipulated.\n\t\t\t * @param {String} propertyName The name of the property of entity which should be populated.\n\t\t\t * @param {Object} cache An instance of another caching service that can provide the complex\n\t\t\t * type instances which are being referenced in entity.\n\t\t\t * @param {Boolean} [force=false] If true, all complex types will be replaced with references to the\n\t\t\t * instances in cache; otherwise, only properties that are string representations of complex type IDs will be replaced.\n\t\t\t * @returns {Promise}\n\t\t\t */\n\t\t\tcacheService.populateComplex = function( entity, propertyName, cache, force ) {\n\t\t\t\t// If the target property is an array, ...\n\t\t\t\tif( Array.isArray( entity[ propertyName ] ) ) {\n\t\t\t\t\t// ...map the elements in the array to promises.\n\t\t\t\t\tvar promises = entity[ propertyName ].map( function mapElementToPromise( element, index ) {\n\t\t\t\t\t\t// We usually assume the properties to be strings (the ID of the referenced complex).\n\t\t\t\t\t\tif( typeof entity[ propertyName ][ index ] !== \"string\" ) {\n\t\t\t\t\t\t\t// If \"force\" is enabled, we check if this non-string property is an object and has an \"id\" member, which is a string.\n\t\t\t\t\t\t\tif( force && typeof entity[ propertyName ][ index ] === \"object\" && typeof entity[ propertyName ][ index ].id === \"string\" ) {\n\t\t\t\t\t\t\t\t// If that is true, then we replace the whole object with the ID and continue as usual.\n\t\t\t\t\t\t\t\tentity[ propertyName ][ index ] = entity[ propertyName ][ index ].id;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn $q.when( false );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Treat the property as an ID and read the complex with that ID from the cache.\n\t\t\t\t\t\treturn cache.read( entity[ propertyName ][ index ] )\n\t\t\t\t\t\t\t.then( function onComplexRetrieved( complex ) {\n\t\t\t\t\t\t\t\t// When the complex was retrieved, store it back into the array.\n\t\t\t\t\t\t\t\tentity[ propertyName ][ index ] = complex;\n\t\t\t\t\t\t\t} )\n\t\t\t\t\t} );\n\n\t\t\t\t\treturn $q.all( promises );\n\t\t\t\t} else {\n\t\t\t\t\t// We usually assume the properties to be strings (the ID of the referenced complex).\n\t\t\t\t\tif( typeof entity[ propertyName ] !== \"string\" ) {\n\t\t\t\t\t\t// If \"force\" is enabled, we check if this non-string property is an object and has an \"id\" member, which is a string.\n\t\t\t\t\t\tif( force && typeof entity[ propertyName ] === \"object\" && typeof entity[ propertyName ].id === \"string\" ) {\n\t\t\t\t\t\t\t// If that is true, then we replace the whole object with the ID and continue as usual.\n\t\t\t\t\t\t\tentity[ propertyName ] = entity[ propertyName ].id;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn $q.when( false );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Treat the property as an ID and read the complex with that ID from the cache.\n\t\t\t\t\treturn cache.read( entity[ propertyName ] )\n\t\t\t\t\t\t.then( function onComplexRetrieved( complex ) {\n\t\t\t\t\t\t\t// When the complex was retrieved, store it back into the entity.\n\t\t\t\t\t\t\tentity[ propertyName ] = complex;\n\t\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// Listen for entity broadcasts. These are sent when a record is received through a websocket.\n\t\t\t$rootScope.$on( configuration.entityName, function( event, args ) {\n\t\t\t\tvar entityReceived = args;\n\n\t\t\t\t// Determine if the received record consists ONLY of an id property,\n\t\t\t\t// which would mean that this record was deleted from the backend.\n\t\t\t\tif( 1 == Object.keys( entityReceived ).length && entityReceived.hasOwnProperty( \"id\" ) ) {\n\t\t\t\t\t$log.info( \"Entity was deleted from the server. Updating cache...\" );\n\t\t\t\t\tremoveEntityFromCache( entityReceived.id );\n\t\t\t\t} else {\n\t\t\t\t\tupdateCacheWithEntity( cacheService.deserializer( entityReceived ) );\n\t\t\t\t}\n\t\t\t} );\n\t\t\t$rootScope.$on( configuration.collectionName, function( event, args ) {\n\t\t\t\tvar collectionReceived = args;\n\n\t\t\t\t// Clear current cache before importing collection\n\t\t\t\twhile( 0 < cacheService.entityCache.length ) {\n\t\t\t\t\tcacheService.entityCache.pop();\n\t\t\t\t}\n\n\t\t\t\tcollectionReceived.forEach( function addEntityToCache( entityReceived ) {\n\t\t\t\t\tupdateCacheWithEntity( cacheService.deserializer( entityReceived ) );\n\t\t\t\t} );\n\t\t\t} );\n\n\n\t\t\tabsync.on( configuration.entityName, function( message ) {\n\t\t\t\t$rootScope.$broadcast( configuration.entityName, message[ configuration.entityName ] );\n\t\t\t} );\n\t\t\tabsync.on( configuration.collectionName, function( message ) {\n\t\t\t\t$rootScope.$broadcast( configuration.collectionName, message[ configuration.collectionName ] );\n\t\t\t} );\n\n\t\t\treturn cacheService;\n\t\t}\n\t}\n\n\tfunction serializationNoop( model ) {\n\t\treturn model;\n\t}\n\n}());\n"],"sourceRoot":"/source/"}