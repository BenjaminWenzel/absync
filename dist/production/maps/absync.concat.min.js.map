{"version":3,"sources":["_absync.module.js","absync.js","absync.concat.js","cache-service.js","configuration.js","noop-log.js","uncached.js"],"names":["angular","module","getAbsyncProvider","$provide","absyncCache","AbsyncProvider","self","this","__provide","__absyncCache","__ioSocket","__registerLater","__collections","__entities","AbsyncService","parentProvider","__absyncProvider","provider","$inject","prototype","configure","configuration","debug","socket","isSocket","io","Socket","Error","length","forEach","__registerListener","bind","listener","$get","__handleEntityEvent","eventName","callback","collection","name","service","entity","_absyncProvider","on","push","removeListener","emit","data","apply","arguments","getServiceConstructor","CacheService","$http","$injector","$log","$q","$rootScope","absync","absyncNoopLog","absyncUncachedFilter","_injector","injector","_injectorHasModel","has","model","_model","get","serializeModel","serialize","serializationNoop","deserializeModel","deserialize","entityCache","collectionName","__entityCacheRaw","enableRequestCache","__requestCache","allowBrowserCache","merge","sync","request","__uncached","__dataAvailableDeferred","defer","__objectsAvailableDeferred","dataAvailable","promise","objectsAvailable","httpInterface","logInterface","scope","q","logPrefix","toLocaleUpperCase","forceEarlyCacheUpdate","throwFailures","serializer","deserializer","entityName","__onEntityOnWebsocket","__onCollectionOnWebsocket","$on","__onEntityReceived","__onCollectionReceived","then","__onDataAvailable","info","afterEntityStored","serverResponse","newEntity","__updateCacheWithEntity","onEntityStorageFailure","error","$emit","message","$broadcast","rawData","deserializeCollectionEntry","rawEntity","Array","isArray","resolve","cache","deserialized","event","args","_entityReceived","Object","keys","hasOwnProperty","__removeEntityFromCache","id","addEntityToCache","entityReceived","_collectionReceived","ensureLoaded","forceReload","onCollectionReceived","onCollectionRetrievalFailure","reject","onSingleEntityReceived","onSingleEntityRetrievalFailure","collectionUri","entityUri","when","all","read","onEntityRetrieved","onEntityRetrievalFailure","entityIndex","__requestEntity","remoteRequestFromCache","requestUri","update","reduced","reduceComplex","serialized","wrappedEntity","put","post","patch","create","onEntityDeleted","entityId","onEntityDeletionFailed","entityToCache","updated","copyFrom","extend","found","targetEntity","splice","lookupTableById","lookupTable","arrayInsteadOfObject","result","propertyName","populateComplex","force","mapElementToPromise","element","index","onComplexRetrieved","complex","promises","map","constant","AbsyncServiceConfigurationFactory","AbsyncServiceConfiguration","_modelName","constructor","toLowerCase","undefined","noop","uncachedFilterProvider","uncachedFilter","url","delimiter","indexOf","discriminator","Date","getTime","filter"],"mappings":"CAAC,WACD,YAGAA,SAAQC,OAAQ,gBCJf,WACD,YAuBA,SAASC,GAAmBC,EAAUC,GACrC,MAAO,IAAIC,GAAgBF,EAAUC,GAStC,QAASC,GAAgBF,EAAUC,GAClC,GAAIE,GAAOC,IAGXD,GAAKE,UAAgBL,EAErBG,EAAKG,cAAgBL,EAGrBE,EAAKI,WAAa,KAIlBJ,EAAKK,mBAKLL,EAAKM,iBAKLN,EAAKO,cA0HN,QAASC,GAAeC,GACvBR,KAAKS,iBAAmBD,EAtKzBf,QACEC,OAAQ,UACRgB,SAAU,SAAUf,GCgBtBA,EAAkBgB,SAAW,WAAY,eDoCzCb,EAAec,UAAUC,UAAY,SAAmCC,EAAeC,GACtF,GAAIhB,GAAOC,KAGPgB,EAAWF,EAAcE,QAAUF,EAEnCG,EAAWC,IAAMA,GAAGC,QAAUH,YAAkBE,IAAGC,MAEvD,IAAqB,kBAAVH,GAEVjB,EAAKI,WAAaa,QAEZ,CAAA,IAAIC,EAKV,KAAM,IAAIG,OAAO,6EAHjBrB,GAAKI,WAAaa,EAQfjB,EAAKK,gBAAgBiB,SACxBtB,EAAKK,gBAAgBkB,QAASvB,EAAKwB,mBAAmBC,KAAMzB,IAC5DA,EAAKK,oBAGNL,EAAKgB,MAAQA,IAAS,GAGvBjB,EAAec,UAAUW,mBAAqB,SAA0CE,GACvF,GAAI1B,GAAOC,IACXD,GAAK2B,OAAOC,oBAAqBF,EAASG,UAAWH,EAASI,WAS/D/B,EAAec,UAAUkB,WAAa,SAAoCC,EAAMjB,GAC/E,GAAIf,GAAOC,IAIX,IAAID,EAAKM,cAAe0B,GACvB,KAAM,IAAIX,OAAO,+BAAiCW,EAAO,iEAE1D,IAAIhC,EAAKO,WAAYyB,GACpB,KAAM,IAAIX,OAAO,4BAA8BW,EAAO,mGAIvDjB,GAAcC,MAAuC,mBAAxBD,GAAcC,MAAwBhB,EAAKgB,MAAQD,EAAcC,MAI9FhB,EAAKM,cAAe0B,GAAShC,EAAKG,cAAe6B,EAAMjB,GAIvDf,EAAKE,UAAU+B,QAASD,EAAMhC,EAAKM,cAAe0B,KASnDjC,EAAec,UAAUqB,OAAS,SAAgCF,EAAMjB,GACvE,GAAIf,GAAOC,IAIX,IAAID,EAAKO,WAAYyB,GACpB,KAAM,IAAIX,OAAO,4BAA8BW,EAAO,8DAEvD,IAAIhC,EAAKM,cAAe0B,GACvB,KAAM,IAAIX,OAAO,+BAAiCW,EAAO,mGAI1DjB,GAAcC,MAAuC,mBAAxBD,GAAcC,MAAwBhB,EAAKgB,MAAQD,EAAcC,MAI9FhB,EAAKO,WAAYyB,GAAShC,EAAKG,cAAe6B,EAAMjB,GAIpDf,EAAKE,UAAU+B,QAASD,EAAMhC,EAAKO,WAAYyB,KAQhDjC,EAAec,UAAUc,KAAO,WAC/B,MAAO,IAAInB,GAAeP,OAqB3BO,EAAcK,UAAUC,UAAY,SAAkCC,EAAeC,GACpF,GAAImB,GAAkBlC,KAAKS,gBAC3ByB,GAAgBrB,UAAWC,EAAeC,IAAS,IAWpDR,EAAcK,UAAUuB,GAAK,SAA2BP,EAAWC,GAClE,GAAIK,GAAkBlC,KAAKS,iBACvBV,EAAkBC,IAGtB,OAAKkC,GAAgB/B,WAedJ,EAAK4B,oBAAqBC,EAAWC,GAbvCK,EAAgB9B,gBAAgBiB,OAAS,KAErC,MAIRa,EAAgB9B,gBAAgBgC,MAC/BR,UAAYA,EACZC,SAAYA,IAEN,OAYTtB,EAAcK,UAAUe,oBAAsB,SAA0CC,EAAWC,GAClG,GAAIK,GAAkBlC,KAAKS,gBAM3B,OAHAyB,GAAgB/B,WAAWgC,GAAIP,EAAWC,GAGnC,WACNK,EAAgB/B,WAAWkC,eAAgBT,EAAWC,KAWxDtB,EAAcK,UAAU0B,KAAO,SAA6BV,EAAWW,EAAMV,GAC5E,GAAIK,GAAkBlC,KAAKS,gBAE3B,KAAKyB,EAAgB/B,WACpB,KAAM,IAAIiB,OAAO,gCAGlBc,GAAgB/B,WAAWmC,KAAMV,EAAWW,EAAM,WAC7CV,GACHA,EAASW,MAAON,EAAgB/B,WAAYsC,iBEpQ9C,WACD,YAuBA,SAASC,GAAuBX,EAAMjB,GAkBrC,QAAS6B,GAAcC,EAAOC,EAAWC,EAAMC,EAAIC,EAAYC,EAAQC,EAAeC,GACrF,GAAIpD,GAAOC,KAGPoD,EAAoBtC,EAAcuC,UAAYR,EAC9CS,EAAoBF,EAAUG,IAAKzC,EAAc0C,MACrD,KAAKF,EACJ,KAAM,IAAIlC,OAAO,4BAA8BW,EAAO,4CAA8CjB,EAAc0C,MAAQ,oCAE3H,IAAIC,GAA0C,gBAAxB3C,GAAc0C,MAAuBJ,EAAUM,IAAK5C,EAAc0C,OAAU1C,EAAc0C,MAG5GG,EAAmBF,EAAOG,WAAa9C,EAAc8C,WAAaC,EAClEC,EAAmBL,EAAOM,aAAejD,EAAciD,aAAeF,CAG1E9D,GAAKgC,KAAgBA,EACrBhC,EAAKe,cAAgBA,EAMrBf,EAAKiE,YAAmBlD,EAAcmD,qBAEtClE,EAAKmE,iBAAmB,KAGxBnE,EAAKoE,oBAAqB,EAE1BpE,EAAKqE,kBAKLrE,EAAKsE,kBAAoB5E,QAAQ6E,UAEhCC,MAAU,EAEVC,SAAU,GACR1D,EAAcuD,mBACjBtE,EAAK0E,WAAoBtB,EAGzBpD,EAAK2E,wBAA6B3B,EAAG4B,QACrC5E,EAAK6E,2BAA6B7B,EAAG4B,QAErC5E,EAAK8E,cAA6B9E,EAAK2E,wBAAwBI,QAE/D/E,EAAKgF,iBAA6BhF,EAAK6E,2BAA2BE,QAIlE/E,EAAKiF,cAAgBpC,EAErB7C,EAAKkF,aAAgBnE,EAAcC,MAAQ+B,EAAOI,EAElDnD,EAAKmF,MAAgBlC,EAErBjD,EAAKoF,EAAgBpC,EAGrBhD,EAAKqF,UAAY,UAAYrD,EAAKsD,oBAAsB,IAIxDtF,EAAKuF,uBAAwB,EAI7BvF,EAAKwF,eAAgB,EAGrBxF,EAAKyF,WAAe7B,EACpB5D,EAAK0F,aAAe3B,EAKpBb,EAAOd,GAAIrB,EAAc4E,WAAY3F,EAAK4F,sBAAsBnE,KAAMzB,IAClEe,EAAcmD,gBACjBhB,EAAOd,GAAIrB,EAAcmD,eAAgBlE,EAAK6F,0BAA0BpE,KAAMzB,IAK/EiD,EAAW6C,IAAK/E,EAAc4E,WAAY3F,EAAK+F,mBAAmBtE,KAAMzB,IACpEe,EAAcmD,gBACjBjB,EAAW6C,IAAK/E,EAAcmD,eAAgBlE,EAAKgG,uBAAuBvE,KAAMzB,IAIjFA,EAAK8E,cACHmB,KAAMjG,EAAKkG,kBAAkBzE,KAAMzB,IAErCA,EAAKkF,aAAaiB,KAAMnG,EAAKqF,UAAY,6BAwX1C,QAASe,GAAmBC,GAC3B,GAAIrG,GAAOC,IAMX,IAAIoG,EAAe7D,KAAMzB,EAAc4E,YAAe,CACrD,GAAIW,GAAYtG,EAAK0F,aAAcW,EAAe7D,KAAMzB,EAAc4E,YAMtE,OAHI3F,GAAKuF,uBACRvF,EAAKuG,wBAAyBD,GAExBA,EAER,KAAM,IAAIjF,OAAO,+FAAiGN,EAAc4E,WAAa,MAO9I,QAASa,GAAwBH,GAChC,GAAIrG,GAAOC,IAOX,IALAD,EAAKkF,aAAauB,MAAOzG,EAAKqF,UAAY,wCACzCgB,GACDrG,EAAKkF,aAAauB,MAAOJ,GACzBrG,EAAKmF,MAAMuB,MAAO,cAAeL,GAE7BrG,EAAKwF,cACR,KAAMa,GA4RR,MDpaAzD,GAAahC,SAAW,QAAS,YAAa,OAAQ,KAAM,aAAc,SAAU,gBAAiB,wBCvQrGgC,EAAa/B,UAAU+E,sBAAwB,SAA2Ce,GACzF,GAAI3G,GAAOC,IACXD,GAAKmF,MAAMyB,WAAY7F,EAAc4E,WAAYgB,EAAS5F,EAAc4E,cASzE/C,EAAa/B,UAAUgF,0BAA4B,SAA+Cc,GACjG,GAAI3G,GAAOC,IACXD,GAAKmF,MAAMyB,WAAY7F,EAAcmD,eAAgByC,EAAS5F,EAAcmD,kBAQ7EtB,EAAa/B,UAAUqF,kBAAoB,SAAuCW,GA6BjF,QAASC,GAA4BC,GACpC/G,EAAKiE,YAAY5B,KAAMrC,EAAK0F,aAAcqB,IA7B3C,GAAI/G,GAAOC,IAEX,IAAI+G,MAAMC,QAASjH,EAAKiE,aAKvB4C,EAAS9F,EAAcmD,gBAAiB3C,QAASuF,GAIjD9G,EAAK6E,2BAA2BqC,QAASlH,EAAKiE,aAG9CjE,EAAKmF,MAAMyB,WAAY,iBACtB3E,QAAUjC,EACVmH,MAAUnH,EAAKiE,kBAGV,CACN,GAAImD,GAAepH,EAAK0F,aAAcmB,EAAS9F,EAAc4E,YAC7D3F,GAAKuG,wBAAyBa,GAI9BpH,EAAK6E,2BAA2BqC,QAASlH,EAAKiE,eAchDrB,EAAa/B,UAAUkF,mBAAqB,SAAwCsB,EAAOC,GAC1F,GAAItH,GAAkBC,KAClBsH,EAAkBD,CAIlB,KAAME,OAAOC,KAAMF,GAAkBjG,QAAUiG,EAAgBG,eAAgB,OAClF1H,EAAKkF,aAAaiB,KAAMnG,EAAKqF,UAAY,uDACzCrF,EAAK2H,wBAAyBJ,EAAgBK,MAG9C5H,EAAKkF,aAAalE,MAAOhB,EAAKqF,UAAY,qDAC1CrF,EAAKuG,wBAAyBvG,EAAK0F,aAAc6B,MAUnD3E,EAAa/B,UAAUmF,uBAAyB,SAA4CqB,EAAOC,GAYlG,QAASO,GAAkBC,GAC1B,GAAIV,GAAepH,EAAK0F,aAAcoC,EACtC9H,GAAKuG,wBAAyBa,GAb/B,GAAIpH,GAAsBC,KACtB8H,EAAsBT,CAK1BtH,GAAKiE,YAAY3C,OAAS,EAG1ByG,EAAoBxG,QAASsG,IAa9BjF,EAAa/B,UAAUmH,aAAe,SAAoCC,GA+CzE,QAASC,GAAsB7B,GAC9B,IAAKA,EAAe7D,KAAMzB,EAAcmD,gBACvC,KAAM,IAAI7C,OAAO,+FAAiGN,EAAcmD,eAAiB,KAGlJlE,GAAKmE,iBAAmBkC,EAAe7D,KACvCxC,EAAK2E,wBAAwBuC,QAASb,EAAe7D,MAOtD,QAAS2F,GAA8B9B,GACtCrG,EAAKkF,aAAauB,MAAOzG,EAAKqF,UAAY,qDACzCgB,GACDrG,EAAKmE,iBAAmB,KAExBnE,EAAKmF,MAAMuB,MAAO,cAAeL,GACjCrG,EAAK2E,wBAAwByD,OAAQ/B,GAOtC,QAASgC,GAAwBhC,GAChC,IAAKA,EAAe7D,KAAMzB,EAAc4E,YACvC,KAAM,IAAItE,OAAO,+FAAiGN,EAAc4E,WAAa,KAG9I3F,GAAKmE,iBAAmBkC,EAAe7D,KACvCxC,EAAK2E,wBAAwBuC,QAASb,EAAe7D,MAOtD,QAAS8F,GAAgCjC,GACxCrG,EAAKkF,aAAauB,MAAOzG,EAAKqF,UAAY,iDACzCgB,GACDrG,EAAKmE,iBAAmB,KAExBnE,EAAKmF,MAAMuB,MAAO,cAAeL,GACjCrG,EAAK2E,wBAAwByD,OAAQ/B,GA3FtC,GAAIrG,GAAOC,IAKX,IAHAgI,EAAcA,KAAgB,EAG1B,OAASjI,EAAKmE,kBAAoB8D,EAGrC,GAFAjI,EAAKmE,oBAEApD,EAAcmD,gBAAmBnD,EAAcwH,cAenDvI,EAAKkF,aAAaiB,KAAMnG,EAAKqF,UAAY,eAAiBtE,EAAcmD,eAAiB,iBACzFlE,EAAKiF,cACHtB,IAAK5C,EAAcuD,kBAAkBE,KAAOzD,EAAcwH,cAAgBvI,EAAK0E,WAC/E3D,EAAcwH,gBACdtC,KAAMiC,EAAsBC,OAnBqC,CACnE,IAAIpH,EAAc4E,aAAc5E,EAAcyH,UAU7C,MAAOxI,GAAKoF,EAAEqD,QATdzI,GAAKmE,oBACLnE,EAAKiF,cACHtB,IAAK5C,EAAcuD,kBAAkBE,KAAOzD,EAAcyH,UAAYxI,EAAK0E,WAC3E3D,EAAcyH,YACdvC,KAAMoC,EAAwBC,GAmBnC,MAAOtI,GAAKoF,EAAEsD,KAEZ1I,EAAK8E,cACL9E,EAAKgF,mBAELiB,KAAM,WACN,MAAOjG,GAAKiE,eAwDfrB,EAAa/B,UAAU2D,KAAO,WAC7B,GAAIxE,GAAOC,IACX,OAAOD,GAAKgI,cAAc,IAU3BpF,EAAa/B,UAAU8H,KAAO,SAA4Bf,EAAIK,GA4B7D,QAASW,GAAmBvC,GAC3B,IAAKA,EAAe7D,KAAMzB,EAAc4E,YACvC,KAAM,IAAItE,OAAO,+FAAiGN,EAAc4E,WAAa,KAO9I,IAAIyB,GAAepH,EAAK0F,aAAcW,EAAe7D,KAAMzB,EAAc4E,YAEzE,OADA3F,GAAKuG,wBAAyBa,GACvBA,EAOR,QAASyB,GAA0BxC,GAKlC,GAJArG,EAAKkF,aAAauB,MAAOzG,EAAKqF,UAAY,sCAAwCuC,EAAK,qBACtFvB,GACDrG,EAAKmF,MAAMuB,MAAO,cAAeL,GAE7BrG,EAAKwF,cACR,KAAMa,GAnDR,GAAIrG,GAAOC,IAMX,IAJAgI,EAAcA,KAAgB,EAE9BjI,EAAKkF,aAAalE,MAAOhB,EAAKqF,UAAY,sBAAwBuC,EAAK,kBAAoBK,EAAc,OAEpGA,EAEJ,IAAK,GAAIa,GAAc,EAAG5G,EAASlC,EAAKiE,YAAa,GAChD6E,EAAc9I,EAAKiE,YAAY3C,SAC7BwH,EAAa5G,EAASlC,EAAKiE,YAAa6E,GAC9C,GAAI5G,EAAO0F,KAAOA,EAEjB,MADA5H,GAAKkF,aAAalE,MAAOhB,EAAKqF,UAAY,sBAAwBuC,EAAK,2BAChE5H,EAAKoF,EAAEqD,KAAMvG,EAOvB,OAFAlC,GAAKkF,aAAalE,MAAOhB,EAAKqF,UAAY,sBAAwBuC,EAAK,8BAEhE5H,EAAK+I,gBAAiBnB,GAC3B3B,KAAM2C,EAAmBC,IAyC5BjG,EAAa/B,UAAUkI,gBAAkB,SAAqCnB,GAqB7E,QAASoB,GAAwBpB,EAAIvB,GAEpC,aADOrG,GAAKqE,eAAgBuD,GACrBvB,EAtBR,GAAIrG,GAAOC,IAEX,IAAID,EAAKoE,oBAAsBpE,EAAKqE,gBAAkBrE,EAAKqE,eAAgBuD,GAE1E,MADA5H,GAAKkF,aAAalE,MAAOhB,EAAKqF,UAAY,sBAAwBuC,EAAK,gCAChE5H,EAAKqE,eAAgBuD,EAG7B,IAAIqB,GAAalI,EAAcyH,WAAcZ,EAAO,IAAMA,EAAO,IAG7DnD,EAAUzE,EAAKiF,cACjBtB,IAAK5C,EAAcuD,kBAAkBG,QAAUwE,EAAajJ,EAAK0E,WAAYuE,IAC7EhD,KAAM+C,EAAuBvH,KAAMzB,EAAM4H,GAM3C,OAJI5H,GAAKoE,oBAAsBpE,EAAKqE,iBACnCrE,EAAKqE,eAAgBuD,GAAOnD,GAGtBA,GAaR7B,EAAa/B,UAAUqI,OAAS,SAA8BhH,GAC7D,GAAIlC,GAAOC,KAGPkJ,EAAanJ,EAAKoJ,cAAelH,GAEjCmH,EAAarJ,EAAKyF,WAAY0D,GAG9BG,IAIJ,OAHAA,GAAevI,EAAc4E,YAAe0D,EAGxC,mBAAuBnH,GAAO0F,GAC1B5H,EAAKiF,cACVsE,IAAKxI,EAAcyH,UAAY,IAAMtG,EAAO0F,GAAI0B,GAChDrD,KAAMG,EAAkB3E,KAAMzB,GAAQwG,EAAuB/E,KAAMzB,IAI9DA,EAAKiF,cACVuE,KAAMzI,EAAcwH,cAAee,GACnCrD,KAAMG,EAAkB3E,KAAMzB,GAAQwG,EAAuB/E,KAAMzB,KAIvE4C,EAAa/B,UAAU4I,MAAQ,SAA6BvH,GAC3D,GAAIlC,GAAOC,KAGPkJ,EAAanJ,EAAKoJ,cAAelH,GAEjCmH,EAAarJ,EAAKyF,WAAY0D,GAG9BG,IAIJ,IAHAA,EAAevI,EAAc4E,YAAe0D,EAGxC,mBAAuBnH,GAAO0F,GACjC,MAAO5H,GAAKiF,cACVwE,MAAO1I,EAAcyH,UAAY,IAAMtG,EAAO0F,GAAI0B,GAClDrD,KAAMG,EAAkB3E,KAAMzB,GAAQwG,EAAuB/E,KAAMzB,GAGrE,MAAM,IAAIqB,OAAO,sEAOnBuB,EAAa/B,UAAU6I,OAAS9G,EAAa/B,UAAUqI,OA8CvDtG,EAAa/B,UAAb+B,UAAgC,SAA8BV,GAa7D,QAASyH,GAAiBtD,GACzB,MAAOrG,GAAK2H,wBAAyBiC,GAOtC,QAASC,GAAwBxD,GAIhC,GAHArG,EAAKkF,aAAauB,MAAOJ,EAAe7D,MACxCxC,EAAKmF,MAAMuB,MAAO,cAAeL,GAE7BrG,EAAKwF,cACR,KAAMa,GAzBR,GAAIrG,GAAOC,KAEP2J,EAAW1H,EAAO0F,EACtB,OAAO5H,GAAKiF,cAALjF,UACGe,EAAcyH,UAAY,IAAMoB,GACxC3D,KAAM0D,GAFD3J,SAGE6J,IA6BVjH,EAAa/B,UAAU0F,wBAA0B,SAA6CuD,GAC7F,GAAI9J,GAAOC,IAKX,IAHAD,EAAKkF,aAAaiB,KAAMnG,EAAKqF,UAAY,qBAAwByE,EAAclC,IAAM5H,EAAKgC,MAAS,cAClG8H,IAEI9C,MAAMC,QAASjH,EAAKiE,aAwBxB,MAtBAjE,GAAKmF,MAAMyB,WAAY,uBAErB3E,QAAUjC,EACVmH,MAAUnH,EAAKiE,YACf/B,OAAUlC,EAAKiE,YACf8F,QAAUD,IAG6B,kBAA9B9J,GAAKiE,YAAY+F,SAC3BhK,EAAKiE,YAAY+F,SAAUF,GAG3BpK,QAAQuK,OAAQjK,EAAKiE,YAAa6F,OAInC9J,GAAKmF,MAAMyB,WAAY,iBAErB3E,QAAUjC,EACVmH,MAAUnH,EAAKiE,YACf/B,OAAUlC,EAAKiE,aAMlB,KAAK,GADDiG,IAAQ,EACHpB,EAAc,EAAG5G,EAASlC,EAAKiE,YAAa,GAChD6E,EAAc9I,EAAKiE,YAAY3C,SAC7BwH,EAAa5G,EAASlC,EAAKiE,YAAa6E,GAC9C,GAAI5G,EAAO0F,IAAMkC,EAAclC,GAAK,CAEnC5H,EAAKmF,MAAMyB,WAAY,uBAErB3E,QAAUjC,EACVmH,MAAUnH,EAAKiE,YACf/B,OAAUlC,EAAKiE,YAAa6E,GAC5BiB,QAAUD,GAIZ,IAAIK,GAAenK,EAAKiE,YAAa6E,EACA,mBAA1BqB,GAAaH,SACvBG,EAAaH,SAAUF,GAGvBpK,QAAQuK,OAAQE,EAAcL,GAG/BI,GAAQ,EAGRlK,EAAKmF,MAAMyB,WAAY,iBAErB3E,QAAUjC,EACVmH,MAAUnH,EAAKiE,YACf/B,OAAUlC,EAAKiE,YAAa6E,IAE9B,OAKGoB,IACJlK,EAAKmF,MAAMyB,WAAY,mBACtB3E,QAAUjC,EACVmH,MAAUnH,EAAKiE,YACf/B,OAAU4H,IAGX9J,EAAKiE,YAAY5B,KAAMyH,GAEvB9J,EAAKmF,MAAMyB,WAAY,aACtB3E,QAAUjC,EACVmH,MAAUnH,EAAKiE,YACf/B,OAAU4H,MAUblH,EAAa/B,UAAU8G,wBAA0B,SAA6CC,GAG7F,IAAK,GAFD5H,GAAOC,KAEF6I,EAAc,EAAG5G,EAASlC,EAAKiE,YAAa,GAChD6E,EAAc9I,EAAKiE,YAAY3C,SAC7BwH,EAAa5G,EAASlC,EAAKiE,YAAa6E,GAC9C,GAAI5G,EAAO0F,IAAMA,EAAK,CAErB5H,EAAKmF,MAAMyB,WAAY,uBACtB3E,QAAUjC,EACVmH,MAAUnH,EAAKiE,YACf/B,OAAUA,IAIXlC,EAAKiE,YAAYmG,OAAQtB,EAAa,GAGtC9I,EAAKmF,MAAMyB,WAAY,iBACtB3E,QAAUjC,EACVmH,MAAUnH,EAAKiE,YACf/B,OAAUA,GAEX,SAUHU,EAAa/B,UAAUwJ,gBAAkB,WAKxC,IAAK,GAJDrK,GAAOC,KAGPqK,KACKxB,EAAc,EAClBA,EAAc9I,EAAKiE,YAAY3C,SAC7BwH,EACNwB,EAAatK,EAAKiE,YAAa6E,GAAclB,IAAO5H,EAAKiE,YAAa6E,EAEvE,OAAOwB,IAUR1H,EAAa/B,UAAUuI,cAAgB,SAAqClH,EAAQqI,GACnF,GAAIvK,GAAOC,KAEPuK,EAASD,OACb,KAAK,GAAIE,KAAgBvI,GACnBA,EAAOwF,eAAgB+C,KAKxBzD,MAAMC,QAAS/E,EAAQuI,IAC1BD,EAAQC,GAAiBzK,EAAKoJ,cAAelH,EAAQuI,IAAgB,GAKlEvI,EAAQuI,IAAkBvI,EAAQuI,GAAe7C,GACpD4C,EAAQC,GAAiBvI,EAAQuI,GAAe7C,GAKjD4C,EAAQC,GAAiBvI,EAAQuI,GAElC,OAAOD,IAaR5H,EAAa/B,UAAU6J,gBAAkB,SAAuCxI,EAAQuI,EAActD,EAAOwD,GA4B5G,QAASC,GAAqBC,EAASC,GAiBtC,QAASC,GAAoBC,GAG5B,MADA9I,GAAQuI,GAAgBK,GAAUE,EAC3B9I,EAlBR,GAA+C,gBAApCA,GAAQuI,GAAgBK,GAAuB,CAEzD,IAAIH,GAAoD,gBAApCzI,GAAQuI,GAAgBK,IAAsE,gBAAvC5I,GAAQuI,GAAgBK,GAAQlD,GAK1G,MAAO5H,GAAKoF,EAAEqD,MAAM,EAHpBvG,GAAQuI,GAAgBK,GAAU5I,EAAQuI,GAAgBK,GAAQlD,GAQpE,MAAOT,GAAMwB,KAAMzG,EAAQuI,GAAgBK,IACzC7E,KAAM8E,GAST,QAASA,GAAoBC,GAE5B9I,EAAQuI,GAAiBO,EArD1B,GAAIhL,GAAOC,IAGX,IAAI+G,MAAMC,QAAS/E,EAAQuI,IAAmB,CAE7C,GAAIQ,GAAW/I,EAAQuI,GAAeS,IAAKN,EAE3C,OAAO5K,GAAKoF,EAAEsD,IAAKuC,GAInB,GAAsC,gBAA3B/I,GAAQuI,GAA8B,CAEhD,IAAIE,GAA2C,gBAA3BzI,GAAQuI,IAAoE,gBAA9BvI,GAAQuI,GAAe7C,GAKxF,MAAO5H,GAAKoF,EAAEqD,MAAM,EAHpBvG,GAAQuI,GAAiBvI,EAAQuI,GAAe7C,GAQlD,MAAOT,GAAMwB,KAAMzG,EAAQuI,IACzBxE,KAAM8E,IAiCHnI,EAGR,QAASkB,GAAmBL,GAC3B,MAAOA,GAnzBR/D,QACEC,OAAQ,UACRwL,SAAU,cAAexI,MChB1B,WACD,YAOA,SAASyI,KACR,MAAOC,GA4BR,QAASA,GAA4B5H,EAAO8E,EAAeC,EAAWtE,EAAgByB,EAAY3B,EAAaH,EAAWP,EAAUtC,EAAOsD,GAC1IrE,KAAKwD,MAAgBA,EACrBxD,KAAKsI,cAAgBA,EACrBtI,KAAKuI,UAAgBA,CAErB,IAAI8C,GAAkB7H,EAAM5C,UAAU0K,YAAYvJ,KAAKwJ,aACvDvL,MAAKiE,eAAiBA,GAAoBoH,EAAa,IACvDrL,KAAK0F,WAAiBA,GAAc2F,EAEpCrL,KAAK+D,YAAcA,GAAeyH,OAClCxL,KAAK4D,UAAcA,GAAa4H,OAEhCxL,KAAKqD,SAAWA,GAAYmI,OAE5BxL,KAAKe,MAAQA,IAAS,EAEtBf,KAAKqE,kBAAoB5E,QAAQ6E,UAChCC,MAAU,EACVC,SAAU,GACRH,GApDJ5E,QACEC,OAAQ,UACRsC,QAAS,6BAA8BmJ,MCNxC,WACD,YAGA1L,SACEC,OAAQ,UACRwL,SAAU,iBACVnK,MAAQtB,QAAQgM,KAChBvF,KAAQzG,QAAQgM,KAChBjF,MAAQ/G,QAAQgM,UCTjB,WACD,YAOA,SAASC,KAGR,QAASC,GAAgBC,GACxB,IAAKA,EACJ,MAAOA,EAGR,IAAIC,GAAgB,GAAKD,EAAIE,QAAS,KAAQ,IAAM,IAChDC,GAAgB,GAAIC,OAAOC,SAE/B,OAAOL,GAAMC,EAAY,IAAME,EAVhC,MAAOJ,GALRlM,QACEC,OAAQ,UACRwM,OAAQ,iBAAkBR","file":"absync.concat.min.js","sourcesContent":["/* globals angular */\n\nangular.module( \"absync\", [] );\n","/* globals angular, io */\n\n/**\n * Please make note of the following conventions:\n * 1. Function-scope local variables must be prefixed with a single underscore.\n *    This indicates a temporary variable.\n * 2. Private variables that are persisted onto publicly accessible entities must be prefixed with two underscores.\n *    This indicates a publicly visible, private variable.\n *    Hiding private variables, by using closures, is discouraged.\n *    Modifying these values from outside of absync is discouraged, but should be respected whenever possible.\n */\n\nangular\n\t.module( \"absync\" )\n\t.provider( \"absync\", getAbsyncProvider );\n\n/**\n * Retrieves the absync provider.\n * @param {angular.auto.IProvideService|Object} $provide The $provide provider\n * @param {Function} absyncCache The AbsyncCache service constructor.\n * @ngInject\n */\nfunction getAbsyncProvider( $provide, absyncCache ) {\n\treturn new AbsyncProvider( $provide, absyncCache );\n}\n\n/**\n * Retrieves the absync provider.\n * @param {angular.auto.IProvideService|Object} $provide The $provide provider\n * @param {Function} absyncCache The AbsyncCache service constructor.\n * @constructor\n */\nfunction AbsyncProvider( $provide, absyncCache ) {\n\tvar self = this;\n\n\t// Store a reference to the provide provider.\n\tself.__provide     = $provide;\n\t// Store a reference to the cache service constructor.\n\tself.__absyncCache = absyncCache;\n\n\t// A reference to the socket.io instance we're using to receive updates from the server.\n\tself.__ioSocket = null;\n\t// We usually register event listeners on the socket.io instance right away.\n\t// If socket.io was not connected when a service was constructed, we put the registration request\n\t// into this array and register it as soon as socket.io is configured.\n\tself.__registerLater = [];\n\n\t// The collections that absync provides.\n\t// The keys are the names of the collections, the value contains the constructor of\n\t// the respective cache service.\n\tself.__collections = {};\n\n\t// The entities that absync provides.\n\t// The keys are the names of the entities, the value contains the constructor of\n\t// the respective cache service.\n\tself.__entities = {};\n}\n\n/**\n * Register the configurator on the provider itself to allow early configuration during setup phase.\n * It is recommended to configure absync within a configuration phase of a module.\n * @param {io.Socket|Function|Object} configuration The socket.io instance to use.\n * Can also be a constructor for a socket.\n * Can also be an object with a \"socket\" member that provides either of the above.\n * @param {Boolean} [debug=false] Enable additional debugging output.\n */\nAbsyncProvider.prototype.configure = function AbsyncProvider$configure( configuration, debug ) {\n\tvar self = this;\n\n\t// If the configuration has a \"socket\" member, unpack it.\n\tvar socket   = configuration.socket || configuration;\n\t// Determine if the socket is an io.Socket.\n\tvar isSocket = io && io.Socket && socket instanceof io.Socket;\n\n\tif( typeof socket == \"function\" ) {\n\t\t// Expect the passed socket to be a constructor.\n\t\tself.__ioSocket = socket();\n\n\t} else if( isSocket ) {\n\t\t// Expect the passed socket to be an io.Socket instance.\n\t\tself.__ioSocket = socket;\n\n\t} else {\n\t\tthrow new Error( \"configure() expects input to be a function or a socket.io Socket instance.\" );\n\t}\n\n\t// Check if services already tried to register listeners, if so, register them now.\n\t// This can happen when a service was constructed before absync was configured.\n\tif( self.__registerLater.length ) {\n\t\tself.__registerLater.forEach( self.__registerListener.bind( self ) );\n\t\tself.__registerLater = [];\n\t}\n\n\tself.debug = debug || false;\n};\n\nAbsyncProvider.prototype.__registerListener = function AbsyncProvider$registerListener( listener ) {\n\tvar self = this;\n\tself.$get().__handleEntityEvent( listener.eventName, listener.callback );\n};\n\n/**\n * Request a new synchronized collection.\n * This only registers the intent to use that collection. It will be constructed when it is first used.\n * @param {String} name The name of the collection and service name.\n * @param {AbsyncServiceConfiguration|Object} configuration The configuration for this collection.\n */\nAbsyncProvider.prototype.collection = function AbsyncProvider$collection( name, configuration ) {\n\tvar self = this;\n\n\t// Collection/entity names (and, thus service names) have to be unique.\n\t// We can't create multiple services with the same name.\n\tif( self.__collections[ name ] ) {\n\t\tthrow new Error( \"A collection with the name '\" + name + \"' was already requested. Names for collections must be unique.\" );\n\t}\n\tif( self.__entities[ name ] ) {\n\t\tthrow new Error( \"An entity with the name '\" + name + \"' was already requested. Names for collections must be unique and can't be shared with entities.\" );\n\t}\n\n\t// If no debug flag was set, use the value from the core absync provider.\n\tconfiguration.debug = typeof configuration.debug === \"undefined\" ? self.debug : configuration.debug;\n\n\t// Register the service configuration.\n\t// __absyncCache will return a constructor for a service with the given configuration.\n\tself.__collections[ name ] = self.__absyncCache( name, configuration );\n\n\t// Register the new service.\n\t// Yes, we want an Angular \"service\" here, because we want it constructed with \"new\".\n\tself.__provide.service( name, self.__collections[ name ] );\n};\n\n/**\n * Request a new synchronized entity.\n * This only registers the intent to use that entity. It will be constructed when it is first used.\n * @param {String} name The name of the entity and service name.\n * @param {AbsyncServiceConfiguration|Object} configuration The configuration for this entity.\n */\nAbsyncProvider.prototype.entity = function AbsyncProvider$entity( name, configuration ) {\n\tvar self = this;\n\n\t// Collection/entity names (and, thus service names) have to be unique.\n\t// We can't create multiple services with the same name.\n\tif( self.__entities[ name ] ) {\n\t\tthrow new Error( \"An entity with the name '\" + name + \"' was already requested. Names for entities must be unique.\" );\n\t}\n\tif( self.__collections[ name ] ) {\n\t\tthrow new Error( \"A collection with the name '\" + name + \"' was already requested. Names for entities must be unique and can't be shared with collections.\" );\n\t}\n\n\t// If no debug flag was set, use the value from the core absync provider.\n\tconfiguration.debug = typeof configuration.debug === \"undefined\" ? self.debug : configuration.debug;\n\n\t// Register the service configuration.\n\t// __absyncCache will return a constructor for a service with the given configuration.\n\tself.__entities[ name ] = self.__absyncCache( name, configuration );\n\n\t// Register the new service.\n\t// Yes, we want an Angular \"service\" here, because we want it constructed with \"new\".\n\tself.__provide.service( name, self.__entities[ name ] );\n};\n\n/**\n * Register the service factory.\n * @returns {AbsyncService}\n * @ngInject\n */\nAbsyncProvider.prototype.$get = function AbsyncProvider$$get() {\n\treturn new AbsyncService( this );\n};\n\n/**\n * The service that is received when injecting \"absync\".\n * This service is primarily used internally to set up the connection between socket.io and the individual\n * caching services.\n * @param {AbsyncProvider|Object} parentProvider The AbsyncProvider that provides this service.\n * @constructor\n */\nfunction AbsyncService( parentProvider ) {\n\tthis.__absyncProvider = parentProvider;\n}\n\n/**\n * Configure the socket.io connection for absync.\n * This configuration of absync should usually be performed through the absyncProvider in the configuration\n * phase of a module.\n * @param {io.Socket|Function|Object} configuration The socket.io instance to use.\n * @param {Boolean} [debug=false] Enable additional debug output.\n */\nAbsyncService.prototype.configure = function AbsyncService$configure( configuration, debug ) {\n\tvar _absyncProvider = this.__absyncProvider;\n\t_absyncProvider.configure( configuration, debug || false );\n};\n\n/**\n * Register an event listener that is called when a specific entity is received on the websocket.\n * @param {String} eventName The event name, usually the name of the entity.\n * @param {Function} callback The function to call when the entity is received.\n * @return {Function|null} If the listener could be registered, it returns a function that, when called, removes\n * the event listener.\n * If the listener registration was delayed, null is returned.\n */\nAbsyncService.prototype.on = function AbsyncService$on( eventName, callback ) {\n\tvar _absyncProvider = this.__absyncProvider;\n\tvar self            = this;\n\n\t// If we have no configured socket.io connection yet, remember to register it later.\n\tif( !_absyncProvider.__ioSocket ) {\n\n\t\tif( _absyncProvider.__registerLater.length > 8192 ) {\n\t\t\t// Be defensive, something is probably not right here.\n\t\t\treturn null;\n\t\t}\n\n\t\t// TODO: Use promises here, so that we can always return the event listener removal function.\n\t\t_absyncProvider.__registerLater.push( {\n\t\t\teventName : eventName,\n\t\t\tcallback  : callback\n\t\t} );\n\t\treturn null;\n\t}\n\n\treturn self.__handleEntityEvent( eventName, callback );\n};\n\n/**\n * Register an event listener on the websocket.\n * @param {String} eventName The event name, usually the name of the entity.\n * @param {Function} callback The function to call when the entity is received.\n * @returns {Function}\n */\nAbsyncService.prototype.__handleEntityEvent = function AbsyncService$handleEntityEvent( eventName, callback ) {\n\tvar _absyncProvider = this.__absyncProvider;\n\n\t// Register the callback with socket.io.\n\t_absyncProvider.__ioSocket.on( eventName, callback );\n\n\t// Return a function that removes the listener.\n\treturn function removeListener() {\n\t\t_absyncProvider.__ioSocket.removeListener( eventName, callback );\n\t};\n};\n\n/**\n * Convenience method to allow the user to emit() from the websocket.\n * This is not utilized in absync internally.\n * @param {String} eventName\n * @param {*} data\n * @param {Function} [callback]\n */\nAbsyncService.prototype.emit = function AbsyncService$emit( eventName, data, callback ) {\n\tvar _absyncProvider = this.__absyncProvider;\n\n\tif( !_absyncProvider.__ioSocket ) {\n\t\tthrow new Error( \"socket.io is not initialized.\" );\n\t}\n\n\t_absyncProvider.__ioSocket.emit( eventName, data, function afterEmit() {\n\t\tif( callback ) {\n\t\t\tcallback.apply( _absyncProvider.__ioSocket, arguments );\n\t\t}\n\t} );\n};\n","(function() {\n\"use strict\";\n/* globals angular */\n\nangular.module( \"absync\", [] );\n}());;(function() {\n\"use strict\";\n/* globals angular, io */\n\n/**\n * Please make note of the following conventions:\n * 1. Function-scope local variables must be prefixed with a single underscore.\n *    This indicates a temporary variable.\n * 2. Private variables that are persisted onto publicly accessible entities must be prefixed with two underscores.\n *    This indicates a publicly visible, private variable.\n *    Hiding private variables, by using closures, is discouraged.\n *    Modifying these values from outside of absync is discouraged, but should be respected whenever possible.\n */\n\nangular\n\t.module( \"absync\" )\n\t.provider( \"absync\", getAbsyncProvider );\n\n/**\n * Retrieves the absync provider.\n * @param {angular.auto.IProvideService|Object} $provide The $provide provider\n * @param {Function} absyncCache The AbsyncCache service constructor.\n * @ngInject\n */\nfunction getAbsyncProvider( $provide, absyncCache ) {\n\treturn new AbsyncProvider( $provide, absyncCache );\n}\ngetAbsyncProvider.$inject = [\"$provide\", \"absyncCache\"];\n\n/**\n * Retrieves the absync provider.\n * @param {angular.auto.IProvideService|Object} $provide The $provide provider\n * @param {Function} absyncCache The AbsyncCache service constructor.\n * @constructor\n */\nfunction AbsyncProvider( $provide, absyncCache ) {\n\tvar self = this;\n\n\t// Store a reference to the provide provider.\n\tself.__provide     = $provide;\n\t// Store a reference to the cache service constructor.\n\tself.__absyncCache = absyncCache;\n\n\t// A reference to the socket.io instance we're using to receive updates from the server.\n\tself.__ioSocket = null;\n\t// We usually register event listeners on the socket.io instance right away.\n\t// If socket.io was not connected when a service was constructed, we put the registration request\n\t// into this array and register it as soon as socket.io is configured.\n\tself.__registerLater = [];\n\n\t// The collections that absync provides.\n\t// The keys are the names of the collections, the value contains the constructor of\n\t// the respective cache service.\n\tself.__collections = {};\n\n\t// The entities that absync provides.\n\t// The keys are the names of the entities, the value contains the constructor of\n\t// the respective cache service.\n\tself.__entities = {};\n}\n\n/**\n * Register the configurator on the provider itself to allow early configuration during setup phase.\n * It is recommended to configure absync within a configuration phase of a module.\n * @param {io.Socket|Function|Object} configuration The socket.io instance to use.\n * Can also be a constructor for a socket.\n * Can also be an object with a \"socket\" member that provides either of the above.\n * @param {Boolean} [debug=false] Enable additional debugging output.\n */\nAbsyncProvider.prototype.configure = function AbsyncProvider$configure( configuration, debug ) {\n\tvar self = this;\n\n\t// If the configuration has a \"socket\" member, unpack it.\n\tvar socket   = configuration.socket || configuration;\n\t// Determine if the socket is an io.Socket.\n\tvar isSocket = io && io.Socket && socket instanceof io.Socket;\n\n\tif( typeof socket == \"function\" ) {\n\t\t// Expect the passed socket to be a constructor.\n\t\tself.__ioSocket = socket();\n\n\t} else if( isSocket ) {\n\t\t// Expect the passed socket to be an io.Socket instance.\n\t\tself.__ioSocket = socket;\n\n\t} else {\n\t\tthrow new Error( \"configure() expects input to be a function or a socket.io Socket instance.\" );\n\t}\n\n\t// Check if services already tried to register listeners, if so, register them now.\n\t// This can happen when a service was constructed before absync was configured.\n\tif( self.__registerLater.length ) {\n\t\tself.__registerLater.forEach( self.__registerListener.bind( self ) );\n\t\tself.__registerLater = [];\n\t}\n\n\tself.debug = debug || false;\n};\n\nAbsyncProvider.prototype.__registerListener = function AbsyncProvider$registerListener( listener ) {\n\tvar self = this;\n\tself.$get().__handleEntityEvent( listener.eventName, listener.callback );\n};\n\n/**\n * Request a new synchronized collection.\n * This only registers the intent to use that collection. It will be constructed when it is first used.\n * @param {String} name The name of the collection and service name.\n * @param {AbsyncServiceConfiguration|Object} configuration The configuration for this collection.\n */\nAbsyncProvider.prototype.collection = function AbsyncProvider$collection( name, configuration ) {\n\tvar self = this;\n\n\t// Collection/entity names (and, thus service names) have to be unique.\n\t// We can't create multiple services with the same name.\n\tif( self.__collections[ name ] ) {\n\t\tthrow new Error( \"A collection with the name '\" + name + \"' was already requested. Names for collections must be unique.\" );\n\t}\n\tif( self.__entities[ name ] ) {\n\t\tthrow new Error( \"An entity with the name '\" + name + \"' was already requested. Names for collections must be unique and can't be shared with entities.\" );\n\t}\n\n\t// If no debug flag was set, use the value from the core absync provider.\n\tconfiguration.debug = typeof configuration.debug === \"undefined\" ? self.debug : configuration.debug;\n\n\t// Register the service configuration.\n\t// __absyncCache will return a constructor for a service with the given configuration.\n\tself.__collections[ name ] = self.__absyncCache( name, configuration );\n\n\t// Register the new service.\n\t// Yes, we want an Angular \"service\" here, because we want it constructed with \"new\".\n\tself.__provide.service( name, self.__collections[ name ] );\n};\n\n/**\n * Request a new synchronized entity.\n * This only registers the intent to use that entity. It will be constructed when it is first used.\n * @param {String} name The name of the entity and service name.\n * @param {AbsyncServiceConfiguration|Object} configuration The configuration for this entity.\n */\nAbsyncProvider.prototype.entity = function AbsyncProvider$entity( name, configuration ) {\n\tvar self = this;\n\n\t// Collection/entity names (and, thus service names) have to be unique.\n\t// We can't create multiple services with the same name.\n\tif( self.__entities[ name ] ) {\n\t\tthrow new Error( \"An entity with the name '\" + name + \"' was already requested. Names for entities must be unique.\" );\n\t}\n\tif( self.__collections[ name ] ) {\n\t\tthrow new Error( \"A collection with the name '\" + name + \"' was already requested. Names for entities must be unique and can't be shared with collections.\" );\n\t}\n\n\t// If no debug flag was set, use the value from the core absync provider.\n\tconfiguration.debug = typeof configuration.debug === \"undefined\" ? self.debug : configuration.debug;\n\n\t// Register the service configuration.\n\t// __absyncCache will return a constructor for a service with the given configuration.\n\tself.__entities[ name ] = self.__absyncCache( name, configuration );\n\n\t// Register the new service.\n\t// Yes, we want an Angular \"service\" here, because we want it constructed with \"new\".\n\tself.__provide.service( name, self.__entities[ name ] );\n};\n\n/**\n * Register the service factory.\n * @returns {AbsyncService}\n * @ngInject\n */\nAbsyncProvider.prototype.$get = function AbsyncProvider$$get() {\n\treturn new AbsyncService( this );\n};\n\n/**\n * The service that is received when injecting \"absync\".\n * This service is primarily used internally to set up the connection between socket.io and the individual\n * caching services.\n * @param {AbsyncProvider|Object} parentProvider The AbsyncProvider that provides this service.\n * @constructor\n */\nfunction AbsyncService( parentProvider ) {\n\tthis.__absyncProvider = parentProvider;\n}\n\n/**\n * Configure the socket.io connection for absync.\n * This configuration of absync should usually be performed through the absyncProvider in the configuration\n * phase of a module.\n * @param {io.Socket|Function|Object} configuration The socket.io instance to use.\n * @param {Boolean} [debug=false] Enable additional debug output.\n */\nAbsyncService.prototype.configure = function AbsyncService$configure( configuration, debug ) {\n\tvar _absyncProvider = this.__absyncProvider;\n\t_absyncProvider.configure( configuration, debug || false );\n};\n\n/**\n * Register an event listener that is called when a specific entity is received on the websocket.\n * @param {String} eventName The event name, usually the name of the entity.\n * @param {Function} callback The function to call when the entity is received.\n * @return {Function|null} If the listener could be registered, it returns a function that, when called, removes\n * the event listener.\n * If the listener registration was delayed, null is returned.\n */\nAbsyncService.prototype.on = function AbsyncService$on( eventName, callback ) {\n\tvar _absyncProvider = this.__absyncProvider;\n\tvar self            = this;\n\n\t// If we have no configured socket.io connection yet, remember to register it later.\n\tif( !_absyncProvider.__ioSocket ) {\n\n\t\tif( _absyncProvider.__registerLater.length > 8192 ) {\n\t\t\t// Be defensive, something is probably not right here.\n\t\t\treturn null;\n\t\t}\n\n\t\t// TODO: Use promises here, so that we can always return the event listener removal function.\n\t\t_absyncProvider.__registerLater.push( {\n\t\t\teventName : eventName,\n\t\t\tcallback  : callback\n\t\t} );\n\t\treturn null;\n\t}\n\n\treturn self.__handleEntityEvent( eventName, callback );\n};\n\n/**\n * Register an event listener on the websocket.\n * @param {String} eventName The event name, usually the name of the entity.\n * @param {Function} callback The function to call when the entity is received.\n * @returns {Function}\n */\nAbsyncService.prototype.__handleEntityEvent = function AbsyncService$handleEntityEvent( eventName, callback ) {\n\tvar _absyncProvider = this.__absyncProvider;\n\n\t// Register the callback with socket.io.\n\t_absyncProvider.__ioSocket.on( eventName, callback );\n\n\t// Return a function that removes the listener.\n\treturn function removeListener() {\n\t\t_absyncProvider.__ioSocket.removeListener( eventName, callback );\n\t};\n};\n\n/**\n * Convenience method to allow the user to emit() from the websocket.\n * This is not utilized in absync internally.\n * @param {String} eventName\n * @param {*} data\n * @param {Function} [callback]\n */\nAbsyncService.prototype.emit = function AbsyncService$emit( eventName, data, callback ) {\n\tvar _absyncProvider = this.__absyncProvider;\n\n\tif( !_absyncProvider.__ioSocket ) {\n\t\tthrow new Error( \"socket.io is not initialized.\" );\n\t}\n\n\t_absyncProvider.__ioSocket.emit( eventName, data, function afterEmit() {\n\t\tif( callback ) {\n\t\t\tcallback.apply( _absyncProvider.__ioSocket, arguments );\n\t\t}\n\t} );\n};\n}());;(function() {\n\"use strict\";\n/* globals angular */\n\n/**\n * Please make note of the following conventions:\n * 1. Function-scope local variables must be prefixed with a single underscore.\n *    This indicates a temporary variable.\n * 2. Private variables that are persisted onto publicly accessible entities must be prefixed with two underscores.\n *    This indicates a publicly visible, private variable.\n *    Hiding private variables, by using closures, is discouraged.\n *    Modifying these values from outside of absync is discouraged, but should be respected whenever possible.\n */\n\nangular\n\t.module( \"absync\" )\n\t.constant( \"absyncCache\", getServiceConstructor );\n\n/**\n * A closure to make the configuration available to the cache service.\n * @param {String} name The name of the service.\n * @param {AbsyncServiceConfiguration} configuration The configuration for this service.\n * @returns {CacheService}\n */\nfunction getServiceConstructor( name, configuration ) {\n\t// There is no code here, other than the CacheService definition, followed by \"return CacheService;\"\n\n\t/**\n\t * This service factory is the core of absync.\n\t * It returns a CacheService instance that is specialized to the given configuration.\n\t * This service will handle keep the stored collection in sync.\n\t * @param {angular.IHttpService|Object} $http\n\t * @param {angular.auto.IInjectorService|Object} $injector\n\t * @param {angular.ILogService|Object} $log\n\t * @param {angular.IQService|Object} $q\n\t * @param {angular.IRootScopeService|Object} $rootScope\n\t * @param {AbsyncService} absync\n\t * @param {Object} absyncNoopLog A log interface that does nothing.\n\t * @param {Object} absyncUncachedFilter A filter that mutates URLs so they will bypass the browser cache.\n\t * @returns {CacheService}\n\t * @ngInject\n\t */\n\tfunction CacheService( $http, $injector, $log, $q, $rootScope, absync, absyncNoopLog, absyncUncachedFilter ) {\n\t\tvar self = this;\n\n\t\t// Retrieve a reference to the model of the collection that is being cached.\n\t\tvar _injector         = configuration.injector || $injector;\n\t\tvar _injectorHasModel = _injector.has( configuration.model );\n\t\tif( !_injectorHasModel ) {\n\t\t\tthrow new Error( \"Unable to construct the '\" + name + \"' service, because the referenced model '\" + configuration.model + \"' is not available for injection.\" );\n\t\t}\n\t\tvar _model = ( typeof configuration.model === \"string\" ) ? _injector.get( configuration.model ) : configuration.model;\n\n\t\t// Retrieve the serialization methods.\n\t\tvar serializeModel   = _model.serialize || configuration.serialize || serializationNoop;\n\t\tvar deserializeModel = _model.deserialize || configuration.deserialize || serializationNoop;\n\n\t\t// Store configuration.\n\t\tself.name          = name;\n\t\tself.configuration = configuration;\n\n\t\t// The entity cache must be constructed as an empty array or object, to allow the user to place watchers on it.\n\t\t// We must never replace the cache with a new array or object, we must always manipulate the existing one.\n\t\t// Otherwise watchers will not behave as the user expects them to.\n\t\t/* @type {Array<configuration.model>|configuration.model} */\n\t\tself.entityCache      = configuration.collectionName ? [] : {};\n\t\t// The raw cache is data that hasn't been deserialized and is used internally.\n\t\tself.__entityCacheRaw = null;\n\n\t\t// Should request caching be used at all?\n\t\tself.enableRequestCache = true;\n\t\t// Cache requests made to the backend to avoid multiple, simultaneous requests for the same resource.\n\t\tself.__requestCache     = {};\n\t\t// When we make HTTP requests, the browser is generally allowed to cache the responses.\n\t\t// The server can control this behavior with cache control HTTPS headers.\n\t\t// However, at times it may be desirable to force the browser to always fetch fresh data from the backend.\n\t\t// This hash controls this behavior.\n\t\tself.allowBrowserCache = angular.merge( {}, {\n\t\t\t// Should browser caching be allowed for initial cache sync operations?\n\t\t\tsync    : true,\n\t\t\t// Should browser caching be allowed when we retrieve single entities from the backend?\n\t\t\trequest : true\n\t\t}, configuration.allowBrowserCache );\n\t\tself.__uncached        = absyncUncachedFilter;\n\n\t\t// TODO: Using deferreds is an anti-pattern and probably provides no value here.\n\t\tself.__dataAvailableDeferred    = $q.defer();\n\t\tself.__objectsAvailableDeferred = $q.defer();\n\t\t// A promise that is resolved once initial data synchronization has taken place.\n\t\tself.dataAvailable              = self.__dataAvailableDeferred.promise;\n\t\t// A promise that is resolved once the received data is extended to models.\n\t\tself.objectsAvailable           = self.__objectsAvailableDeferred.promise;\n\n\t\t// Use $http by default and expose it on the service.\n\t\t// This allows the user to set a different, possibly decorated, HTTP interface for this service.\n\t\tself.httpInterface = $http;\n\t\t// Do the same for our logger.\n\t\tself.logInterface  = configuration.debug ? $log : absyncNoopLog;\n\t\t// The scope on which we broadcast all our relevant events.\n\t\tself.scope         = $rootScope;\n\t\t// Keep a reference to $q.\n\t\tself.q             = $q;\n\n\t\t// Prefix log messages with this string.\n\t\tself.logPrefix = \"absync:\" + name.toLocaleUpperCase() + \" \";\n\n\t\t// If enabled, entities received in response to a create or update API call, will be put into the cache.\n\t\t// Otherwise, absync will wait for them to be published through the websocket channel.\n\t\tself.forceEarlyCacheUpdate = false;\n\n\t\t// Throws failures so that they can be handled outside of absync.\n\t\t// Note: This will become the default in future versions.\n\t\tself.throwFailures = false;\n\n\t\t// Expose the serializer/deserializer so that they can be adjusted at any time.\n\t\tself.serializer   = serializeModel;\n\t\tself.deserializer = deserializeModel;\n\n\t\t// Tell absync to register an event listener for both our entity and its collection.\n\t\t// When we receive these events, we broadcast an equal Angular event on the root scope.\n\t\t// This way the user can already peek at the data (manipulating it is discouraged though).\n\t\tabsync.on( configuration.entityName, self.__onEntityOnWebsocket.bind( self ) );\n\t\tif( configuration.collectionName ) {\n\t\t\tabsync.on( configuration.collectionName, self.__onCollectionOnWebsocket.bind( self ) );\n\t\t}\n\n\t\t// Now we listen on the root scope for the same events we're firing above.\n\t\t// This is where our own absync synchronization logic kicks in.\n\t\t$rootScope.$on( configuration.entityName, self.__onEntityReceived.bind( self ) );\n\t\tif( configuration.collectionName ) {\n\t\t\t$rootScope.$on( configuration.collectionName, self.__onCollectionReceived.bind( self ) );\n\t\t}\n\n\t\t// Wait for data to be available.\n\t\tself.dataAvailable\n\t\t\t.then( self.__onDataAvailable.bind( self ) );\n\n\t\tself.logInterface.info( self.logPrefix + \"service was instantiated.\" );\n\t}\n\tCacheService.$inject = [\"$http\", \"$injector\", \"$log\", \"$q\", \"$rootScope\", \"absync\", \"absyncNoopLog\", \"absyncUncachedFilter\"];\n\n\t/**\n\t * Invoked when an entity is received on a websocket.\n\t * Translates the websocket event to an Angular event and broadcasts it on the scope.\n\t * @param {Object} message\n\t * @private\n\t */\n\tCacheService.prototype.__onEntityOnWebsocket = function CacheService$onEntityOnWebsocket( message ) {\n\t\tvar self = this;\n\t\tself.scope.$broadcast( configuration.entityName, message[ configuration.entityName ] );\n\t};\n\n\t/**\n\t * Invoked when a collection is received on a websocket.\n\t * Translates the websocket event to an Angular event and broadcasts it on the scope.\n\t * @param {Object} message\n\t * @private\n\t */\n\tCacheService.prototype.__onCollectionOnWebsocket = function CacheService$onCollectionOnWebsocket( message ) {\n\t\tvar self = this;\n\t\tself.scope.$broadcast( configuration.collectionName, message[ configuration.collectionName ] );\n\t};\n\n\t/**\n\t * Event handler for when the initial badge of raw data becomes available.\n\t * @param {Array<Object>|Object} rawData\n\t * @private\n\t */\n\tCacheService.prototype.__onDataAvailable = function CacheService$onDataAvailable( rawData ) {\n\t\tvar self = this;\n\n\t\tif( Array.isArray( self.entityCache ) ) {\n\t\t\t// The symbol self.entityCache is expected to be an empty array.\n\t\t\t// We initialize it in the constructor to an empty array and we don't expect any writes to have\n\t\t\t// happened to it. In case writes *did* happen, we assume that whoever wrote to it knows what\n\t\t\t// they're doing.\n\t\t\trawData[ configuration.collectionName ].forEach( deserializeCollectionEntry );\n\n\t\t\t// Resolve our \"objects are available\" deferred.\n\t\t\t// TODO: We could just as well initialize objectAvailable to the return value of this call block.\n\t\t\tself.__objectsAvailableDeferred.resolve( self.entityCache );\n\n\t\t\t// Notify the rest of the application about a fresh collection.\n\t\t\tself.scope.$broadcast( \"collectionNew\", {\n\t\t\t\tservice : self,\n\t\t\t\tcache   : self.entityCache\n\t\t\t} );\n\n\t\t} else {\n\t\t\tvar deserialized = self.deserializer( rawData[ configuration.entityName ] );\n\t\t\tself.__updateCacheWithEntity( deserialized );\n\n\t\t\t// Resolve our \"objects are available\" deferred.\n\t\t\t// TODO: We could just as well initialize objectAvailable to the return value of this call block.\n\t\t\tself.__objectsAvailableDeferred.resolve( self.entityCache );\n\t\t}\n\n\t\tfunction deserializeCollectionEntry( rawEntity ) {\n\t\t\tself.entityCache.push( self.deserializer( rawEntity ) );\n\t\t}\n\t};\n\n\t/**\n\t * Event handler for when an entity is received on the root scope.\n\t * @param {Object} event The event object.\n\t * @param {Object} args The raw object as it was read from the wire.\n\t * @private\n\t */\n\tCacheService.prototype.__onEntityReceived = function CacheService$onEntityReceived( event, args ) {\n\t\tvar self            = this;\n\t\tvar _entityReceived = args;\n\n\t\t// Determine if the received record consists ONLY of an id property,\n\t\t// which would mean that this record was deleted from the backend.\n\t\tif( 1 === Object.keys( _entityReceived ).length && _entityReceived.hasOwnProperty( \"id\" ) ) {\n\t\t\tself.logInterface.info( self.logPrefix + \"Entity was deleted from the server. Updating cache…\" );\n\t\t\tself.__removeEntityFromCache( _entityReceived.id );\n\n\t\t} else {\n\t\t\tself.logInterface.debug( self.logPrefix + \"Entity was updated on the server. Updating cache…\" );\n\t\t\tself.__updateCacheWithEntity( self.deserializer( _entityReceived ) );\n\t\t}\n\t};\n\n\t/**\n\t * Event handler for when a collection is received on the root scope.\n\t * @param {Object} event The event object.\n\t * @param {Array<Object>} args The raw collection as it was read from the wire.\n\t * @private\n\t */\n\tCacheService.prototype.__onCollectionReceived = function CacheService$onCollectionReceived( event, args ) {\n\t\tvar self                = this;\n\t\tvar _collectionReceived = args;\n\n\t\t// When we're receiving a full collection, all data we currently have in our cache is useless.\n\t\t// We reset the length of the array here, because assigning a new array would possibly conflict\n\t\t// with watchers placed on the original object.\n\t\tself.entityCache.length = 0;\n\n\t\t// Deserialize the received data and place the models in our cache.\n\t\t_collectionReceived.forEach( addEntityToCache );\n\n\t\tfunction addEntityToCache( entityReceived ) {\n\t\t\tvar deserialized = self.deserializer( entityReceived );\n\t\t\tself.__updateCacheWithEntity( deserialized );\n\t\t}\n\t};\n\n\t/**\n\t * Ensure that the cached collection is retrieved from the server.\n\t * @param {Boolean} [forceReload=false] Should the data be loaded, even if the service already has a local cache?\n\t * @returns {Promise<Array<configuration.model>>|IPromise<Array>|IPromise<void>|Q.Promise<Array<configuration.model>>|angular.IPromise<TResult>}\n\t */\n\tCacheService.prototype.ensureLoaded = function CacheService$ensureLoaded( forceReload ) {\n\t\tvar self = this;\n\n\t\tforceReload = forceReload === true;\n\n\t\t// We only perform any loading, if we don't have raw data cached yet, or if we're forced.\n\t\tif( null === self.__entityCacheRaw || forceReload ) {\n\t\t\tself.__entityCacheRaw = [];\n\n\t\t\tif( !configuration.collectionName || !configuration.collectionUri ) {\n\t\t\t\tif( configuration.entityName && configuration.entityUri ) {\n\t\t\t\t\tself.__entityCacheRaw = {};\n\t\t\t\t\tself.httpInterface\n\t\t\t\t\t\t.get( configuration.allowBrowserCache.sync ? configuration.entityUri : self.__uncached(\n\t\t\t\t\t\t\tconfiguration.entityUri ) )\n\t\t\t\t\t\t.then( onSingleEntityReceived, onSingleEntityRetrievalFailure );\n\n\t\t\t\t} else {\n\t\t\t\t\t// If the user did not provide information necessary to work with a collection, immediately return\n\t\t\t\t\t// a promise for an empty collection. The user could still use read() to grab individual entities.\n\t\t\t\t\treturn self.q.when( [] );\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tself.logInterface.info( self.logPrefix + \"Retrieving '\" + configuration.collectionName + \"' collection…\" );\n\t\t\t\tself.httpInterface\n\t\t\t\t\t.get( configuration.allowBrowserCache.sync ? configuration.collectionUri : self.__uncached(\n\t\t\t\t\t\tconfiguration.collectionUri ) )\n\t\t\t\t\t.then( onCollectionReceived, onCollectionRetrievalFailure );\n\t\t\t}\n\t\t}\n\n\t\t// Return a promise that is resolved once the data was read and converted to models.\n\t\t// When the promise is resolved, it will return a reference to the entity cache.\n\t\treturn self.q.all(\n\t\t\t[\n\t\t\t\tself.dataAvailable,\n\t\t\t\tself.objectsAvailable\n\t\t\t] )\n\t\t\t.then( function dataAvailable() {\n\t\t\t\treturn self.entityCache;\n\t\t\t} );\n\n\t\t/**\n\t\t * Invoked when the collection was received from the server.\n\t\t * @param {angular.IHttpPromiseCallbackArg|Object} serverResponse The reply sent from the server.\n\t\t */\n\t\tfunction onCollectionReceived( serverResponse ) {\n\t\t\tif( !serverResponse.data[ configuration.collectionName ] ) {\n\t\t\t\tthrow new Error( \"The response from the server was not in the expected format. It should have a member named '\" + configuration.collectionName + \"'.\" );\n\t\t\t}\n\n\t\t\tself.__entityCacheRaw = serverResponse.data;\n\t\t\tself.__dataAvailableDeferred.resolve( serverResponse.data );\n\t\t}\n\n\t\t/**\n\t\t * Invoked when there was an error while trying to retrieve the collection from the server.\n\t\t * @param {angular.IHttpPromiseCallbackArg|Object} serverResponse The reply sent from the server.\n\t\t */\n\t\tfunction onCollectionRetrievalFailure( serverResponse ) {\n\t\t\tself.logInterface.error( self.logPrefix + \"Unable to retrieve the collection from the server.\",\n\t\t\t\tserverResponse );\n\t\t\tself.__entityCacheRaw = null;\n\n\t\t\tself.scope.$emit( \"absyncError\", serverResponse );\n\t\t\tself.__dataAvailableDeferred.reject( serverResponse );\n\t\t}\n\n\t\t/**\n\t\t * Invoked when the entity was received from the server.\n\t\t * @param {angular.IHttpPromiseCallbackArg|Object} serverResponse The reply sent from the server.\n\t\t */\n\t\tfunction onSingleEntityReceived( serverResponse ) {\n\t\t\tif( !serverResponse.data[ configuration.entityName ] ) {\n\t\t\t\tthrow new Error( \"The response from the server was not in the expected format. It should have a member named '\" + configuration.entityName + \"'.\" );\n\t\t\t}\n\n\t\t\tself.__entityCacheRaw = serverResponse.data;\n\t\t\tself.__dataAvailableDeferred.resolve( serverResponse.data );\n\t\t}\n\n\t\t/**\n\t\t * Invoked when there was an error while trying to retrieve the entity from the server.\n\t\t * @param {angular.IHttpPromiseCallbackArg|Object} serverResponse The reply sent from the server.\n\t\t */\n\t\tfunction onSingleEntityRetrievalFailure( serverResponse ) {\n\t\t\tself.logInterface.error( self.logPrefix + \"Unable to retrieve the entity from the server.\",\n\t\t\t\tserverResponse );\n\t\t\tself.__entityCacheRaw = null;\n\n\t\t\tself.scope.$emit( \"absyncError\", serverResponse );\n\t\t\tself.__dataAvailableDeferred.reject( serverResponse );\n\t\t}\n\t};\n\n\tCacheService.prototype.sync = function CacheService$sync() {\n\t\tvar self = this;\n\t\treturn self.ensureLoaded( true );\n\t};\n\n\t/**\n\t * Read a single entity from the cache, or load it from the server if required.\n\t * The entity will be placed into the cache.\n\t * @param {String} id The ID of the entity to retrieve.\n\t * @param {Boolean} [forceReload=false] Should the entity be retrieved from the server, even if it is already in the cache?\n\t * @returns {Promise<configuration.model>|IPromise<TResult>|IPromise<void>|angular.IPromise<TResult>}\n\t */\n\tCacheService.prototype.read = function CacheService$read( id, forceReload ) {\n\t\tvar self = this;\n\n\t\tforceReload = forceReload === true;\n\n\t\tself.logInterface.debug( self.logPrefix + \"Requesting entity '\" + id + \"' (forceReload:\" + forceReload + \")…\" );\n\n\t\tif( !forceReload ) {\n\t\t\t// Check if the entity is in the cache and return instantly if found.\n\t\t\tfor( var entityIndex = 0, entity = self.entityCache[ 0 ];\n\t\t\t     entityIndex < self.entityCache.length;\n\t\t\t     ++entityIndex, entity = self.entityCache[ entityIndex ] ) {\n\t\t\t\tif( entity.id === id ) {\n\t\t\t\t\tself.logInterface.debug( self.logPrefix + \"Requested entity  '\" + id + \"' is served from cache.\" );\n\t\t\t\t\treturn self.q.when( entity );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tself.logInterface.debug( self.logPrefix + \"Requested entity  '\" + id + \"' is fetched from backend.\" );\n\n\t\treturn self.__requestEntity( id )\n\t\t\t.then( onEntityRetrieved, onEntityRetrievalFailure );\n\n\t\t/**\n\t\t * Invoked when the entity was retrieved from the server.\n\t\t * @param {angular.IHttpPromiseCallbackArg|Object} serverResponse The reply sent from the server.\n\t\t */\n\t\tfunction onEntityRetrieved( serverResponse ) {\n\t\t\tif( !serverResponse.data[ configuration.entityName ] ) {\n\t\t\t\tthrow new Error( \"The response from the server was not in the expected format. It should have a member named '\" + configuration.entityName + \"'.\" );\n\t\t\t}\n\n\t\t\t// Deserialize the object and place it into the cache.\n\t\t\t// We do not need to check here if the object already exists in the cache.\n\t\t\t// While it could be possible that the same entity is retrieved multiple times, __updateCacheWithEntity\n\t\t\t// will not insert duplicated into the cache.\n\t\t\tvar deserialized = self.deserializer( serverResponse.data[ configuration.entityName ] );\n\t\t\tself.__updateCacheWithEntity( deserialized );\n\t\t\treturn deserialized;\n\t\t}\n\n\t\t/**\n\t\t * Invoked when there was an error while trying to retrieve the entity from the server.\n\t\t * @param {angular.IHttpPromiseCallbackArg|Object} serverResponse The reply sent from the server.\n\t\t */\n\t\tfunction onEntityRetrievalFailure( serverResponse ) {\n\t\t\tself.logInterface.error( self.logPrefix + \"Unable to retrieve entity with ID '\" + id + \"' from the server.\",\n\t\t\t\tserverResponse );\n\t\t\tself.scope.$emit( \"absyncError\", serverResponse );\n\n\t\t\tif( self.throwFailures ) {\n\t\t\t\tthrow serverResponse;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Request an entity from the backend.\n\t * @param {String} id The ID of the entity.\n\t * @returns {Promise<configuration.model>|IPromise<TResult>|IPromise<void>|angular.IPromise<TResult>}\n\t * @private\n\t */\n\tCacheService.prototype.__requestEntity = function CacheService$requestEntity( id ) {\n\t\tvar self = this;\n\n\t\tif( self.enableRequestCache && self.__requestCache && self.__requestCache[ id ] ) {\n\t\t\tself.logInterface.debug( self.logPrefix + \"Entity request    '\" + id + \"' served from request cache.\" );\n\t\t\treturn self.__requestCache[ id ];\n\t\t}\n\n\t\tvar requestUri = configuration.entityUri + ( id ? ( \"/\" + id ) : \"\" );\n\n\t\t// Grab the entity from the backend.\n\t\tvar request = self.httpInterface\n\t\t\t.get( configuration.allowBrowserCache.request ? requestUri : self.__uncached( requestUri ) )\n\t\t\t.then( remoteRequestFromCache.bind( self, id ) );\n\n\t\tif( self.enableRequestCache && self.__requestCache ) {\n\t\t\tself.__requestCache[ id ] = request;\n\t\t}\n\n\t\treturn request;\n\n\t\tfunction remoteRequestFromCache( id, serverResponse ) {\n\t\t\tdelete self.__requestCache[ id ];\n\t\t\treturn serverResponse;\n\t\t}\n\t};\n\n\t/**\n\t * Updates an entity and persists it to the backend and the cache.\n\t * @param {configuration.model} entity\n\t * @return {Promise<configuration.model>|IPromise<TResult>|angular.IPromise<TResult>} A promise that will be resolved with the updated entity.\n\t */\n\tCacheService.prototype.update = function CacheService$update( entity ) {\n\t\tvar self = this;\n\n\t\t// First create a copy of the object, which has complex properties reduced to their respective IDs.\n\t\tvar reduced    = self.reduceComplex( entity );\n\t\t// Now serialize the object.\n\t\tvar serialized = self.serializer( reduced );\n\n\t\t// Wrap the entity in a new object, with a single property, named after the entity type.\n\t\tvar wrappedEntity                         = {};\n\t\twrappedEntity[ configuration.entityName ] = serialized;\n\n\t\t// Check if the entity has an \"id\" property, if it has, we will update. Otherwise, we create.\n\t\tif( \"undefined\" !== typeof entity.id ) {\n\t\t\treturn self.httpInterface\n\t\t\t\t.put( configuration.entityUri + \"/\" + entity.id, wrappedEntity )\n\t\t\t\t.then( afterEntityStored.bind( self ), onEntityStorageFailure.bind( self ) );\n\n\t\t} else {\n\t\t\t// Create a new entity\n\t\t\treturn self.httpInterface\n\t\t\t\t.post( configuration.collectionUri, wrappedEntity )\n\t\t\t\t.then( afterEntityStored.bind( self ), onEntityStorageFailure.bind( self ) );\n\t\t}\n\t};\n\n\tCacheService.prototype.patch = function CacheService$patch( entity ) {\n\t\tvar self = this;\n\n\t\t// First create a copy of the object, which has complex properties reduced to their respective IDs.\n\t\tvar reduced    = self.reduceComplex( entity );\n\t\t// Now serialize the object.\n\t\tvar serialized = self.serializer( reduced );\n\n\t\t// Wrap the entity in a new object, with a single property, named after the entity type.\n\t\tvar wrappedEntity                         = {};\n\t\twrappedEntity[ configuration.entityName ] = serialized;\n\n\t\t// Check if the entity has an \"id\" property, if it has, we will update. Otherwise, we create.\n\t\tif( \"undefined\" !== typeof entity.id ) {\n\t\t\treturn self.httpInterface\n\t\t\t\t.patch( configuration.entityUri + \"/\" + entity.id, wrappedEntity )\n\t\t\t\t.then( afterEntityStored.bind( self ), onEntityStorageFailure.bind( self ) );\n\n\t\t} else {\n\t\t\tthrow new Error( \"Attempted to patch an entity that was never stored on the server.\" );\n\t\t}\n\t};\n\n\t/**\n\t * Creates a new entity and persists it to the backend and the cache.\n\t */\n\tCacheService.prototype.create = CacheService.prototype.update;\n\n\t/**\n\t * Invoked when the entity was stored on the server.\n\t * @param {angular.IHttpPromiseCallbackArg|Object} serverResponse The reply sent from the server.\n\t */\n\tfunction afterEntityStored( serverResponse ) {\n\t\tvar self = this;\n\n\t\t// Writing an entity to the backend will usually invoke an update event to be\n\t\t// broadcast over websockets, where we would also retrieve the updated record.\n\t\t// We still put the updated record we receive here into the cache to ensure early consistency.\n\t\t// TODO: This might actually not be optimal. Consider only handling the websocket update.\n\t\tif( serverResponse.data[ configuration.entityName ] ) {\n\t\t\tvar newEntity = self.deserializer( serverResponse.data[ configuration.entityName ] );\n\n\t\t\t// If early cache updates are forced, put the return entity into the cache.\n\t\t\tif( self.forceEarlyCacheUpdate ) {\n\t\t\t\tself.__updateCacheWithEntity( newEntity );\n\t\t\t}\n\t\t\treturn newEntity;\n\t\t}\n\t\tthrow new Error( \"The response from the server was not in the expected format. It should have a member named '\" + configuration.entityName + \"'.\" );\n\t}\n\n\t/**\n\t * Invoked when there was an error while trying to store the entity on the server.\n\t * @param {angular.IHttpPromiseCallbackArg|Object} serverResponse The reply sent from the server.\n\t */\n\tfunction onEntityStorageFailure( serverResponse ) {\n\t\tvar self = this;\n\n\t\tself.logInterface.error( self.logPrefix + \"Unable to store entity on the server.\",\n\t\t\tserverResponse );\n\t\tself.logInterface.error( serverResponse );\n\t\tself.scope.$emit( \"absyncError\", serverResponse );\n\n\t\tif( self.throwFailures ) {\n\t\t\tthrow serverResponse;\n\t\t}\n\t}\n\n\t/**\n\t * Remove an entity from the cache and have it deleted on the backend.\n\t * @param {Object} entity\n\t */\n\tCacheService.prototype.delete = function CacheService$delete( entity ) {\n\t\tvar self = this;\n\n\t\tvar entityId = entity.id;\n\t\treturn self.httpInterface\n\t\t\t.delete( configuration.entityUri + \"/\" + entityId )\n\t\t\t.then( onEntityDeleted )\n\t\t\t.catch( onEntityDeletionFailed );\n\n\t\t/**\n\t\t * Invoked when the entity was deleted from the server.\n\t\t * @param {angular.IHttpPromiseCallbackArg|Object} serverResponse The reply sent from the server.\n\t\t */\n\t\tfunction onEntityDeleted( serverResponse ) {\n\t\t\treturn self.__removeEntityFromCache( entityId );\n\t\t}\n\n\t\t/**\n\t\t * Invoked when there was an error while trying to delete the entity from the server.\n\t\t * @param {angular.IHttpPromiseCallbackArg|Object} serverResponse The reply sent from the server.\n\t\t */\n\t\tfunction onEntityDeletionFailed( serverResponse ) {\n\t\t\tself.logInterface.error( serverResponse.data );\n\t\t\tself.scope.$emit( \"absyncError\", serverResponse );\n\n\t\t\tif( self.throwFailures ) {\n\t\t\t\tthrow serverResponse;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Put an entity into the cache or update the existing record if the entity was already in the cache.\n\t * @param {Object} entityToCache\n\t * @private\n\t */\n\tCacheService.prototype.__updateCacheWithEntity = function CacheService$updateCacheWithEntity( entityToCache ) {\n\t\tvar self = this;\n\n\t\tself.logInterface.info( self.logPrefix + \"Updating entity '\" + ( entityToCache.id || self.name ) + \"' in cache…\",\n\t\t\tentityToCache );\n\n\t\tif( !Array.isArray( self.entityCache ) ) {\n\t\t\t// Allow the user to intervene in the update process, before updating the entity.\n\t\t\tself.scope.$broadcast( \"beforeEntityUpdated\",\n\t\t\t\t{\n\t\t\t\t\tservice : self,\n\t\t\t\t\tcache   : self.entityCache,\n\t\t\t\t\tentity  : self.entityCache,\n\t\t\t\t\tupdated : entityToCache\n\t\t\t\t} );\n\n\t\t\tif( typeof self.entityCache.copyFrom === \"function\" ) {\n\t\t\t\tself.entityCache.copyFrom( entityToCache );\n\n\t\t\t} else {\n\t\t\t\tangular.extend( self.entityCache, entityToCache );\n\t\t\t}\n\n\t\t\t// After updating the entity, send another event to allow the user to react.\n\t\t\tself.scope.$broadcast( \"entityUpdated\",\n\t\t\t\t{\n\t\t\t\t\tservice : self,\n\t\t\t\t\tcache   : self.entityCache,\n\t\t\t\t\tentity  : self.entityCache\n\t\t\t\t} );\n\t\t\treturn;\n\t\t}\n\n\t\tvar found = false;\n\t\tfor( var entityIndex = 0, entity = self.entityCache[ 0 ];\n\t\t     entityIndex < self.entityCache.length;\n\t\t     ++entityIndex, entity = self.entityCache[ entityIndex ] ) {\n\t\t\tif( entity.id == entityToCache.id ) {\n\t\t\t\t// Allow the user to intervene in the update process, before updating the entity.\n\t\t\t\tself.scope.$broadcast( \"beforeEntityUpdated\",\n\t\t\t\t\t{\n\t\t\t\t\t\tservice : self,\n\t\t\t\t\t\tcache   : self.entityCache,\n\t\t\t\t\t\tentity  : self.entityCache[ entityIndex ],\n\t\t\t\t\t\tupdated : entityToCache\n\t\t\t\t\t} );\n\n\t\t\t\t// Use the \"copyFrom\" method on the entity, if it exists, otherwise use naive approach.\n\t\t\t\tvar targetEntity = self.entityCache[ entityIndex ];\n\t\t\t\tif( typeof targetEntity.copyFrom === \"function\" ) {\n\t\t\t\t\ttargetEntity.copyFrom( entityToCache );\n\n\t\t\t\t} else {\n\t\t\t\t\tangular.extend( targetEntity, entityToCache );\n\t\t\t\t}\n\n\t\t\t\tfound = true;\n\n\t\t\t\t// After updating the entity, send another event to allow the user to react.\n\t\t\t\tself.scope.$broadcast( \"entityUpdated\",\n\t\t\t\t\t{\n\t\t\t\t\t\tservice : self,\n\t\t\t\t\t\tcache   : self.entityCache,\n\t\t\t\t\t\tentity  : self.entityCache[ entityIndex ]\n\t\t\t\t\t} );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// If the entity wasn't found in our records, it's a new entity.\n\t\tif( !found ) {\n\t\t\tself.scope.$broadcast( \"beforeEntityNew\", {\n\t\t\t\tservice : self,\n\t\t\t\tcache   : self.entityCache,\n\t\t\t\tentity  : entityToCache\n\t\t\t} );\n\n\t\t\tself.entityCache.push( entityToCache );\n\n\t\t\tself.scope.$broadcast( \"entityNew\", {\n\t\t\t\tservice : self,\n\t\t\t\tcache   : self.entityCache,\n\t\t\t\tentity  : entityToCache\n\t\t\t} );\n\t\t}\n\t};\n\n\t/**\n\t * Removes an entity from the internal cache. The entity is not removed from the backend.\n\t * @param {String} id The ID of the entity to remove from the cache.\n\t * @private\n\t */\n\tCacheService.prototype.__removeEntityFromCache = function CacheService$removeEntityFromCache( id ) {\n\t\tvar self = this;\n\n\t\tfor( var entityIndex = 0, entity = self.entityCache[ 0 ];\n\t\t     entityIndex < self.entityCache.length;\n\t\t     ++entityIndex, entity = self.entityCache[ entityIndex ] ) {\n\t\t\tif( entity.id == id ) {\n\t\t\t\t// Before removing the entity, allow the user to react.\n\t\t\t\tself.scope.$broadcast( \"beforeEntityRemoved\", {\n\t\t\t\t\tservice : self,\n\t\t\t\t\tcache   : self.entityCache,\n\t\t\t\t\tentity  : entity\n\t\t\t\t} );\n\n\t\t\t\t// Remove the entity from the cache.\n\t\t\t\tself.entityCache.splice( entityIndex, 1 );\n\n\t\t\t\t// Send another event to allow the user to take note of the removal.\n\t\t\t\tself.scope.$broadcast( \"entityRemoved\", {\n\t\t\t\t\tservice : self,\n\t\t\t\t\tcache   : self.entityCache,\n\t\t\t\t\tentity  : entity\n\t\t\t\t} );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Retrieve an associative array of all cached entities, which uses the ID of the entity records as the key in the array.\n\t * This is a convenience method that is not utilized internally.\n\t * @returns {Array<configuration.model>}\n\t */\n\tCacheService.prototype.lookupTableById = function CacheService$lookupTableById() {\n\t\tvar self = this;\n\n\t\t// TODO: Keep a copy of the lookup table and only update it when the cached data updates\n\t\tvar lookupTable = [];\n\t\tfor( var entityIndex = 0;\n\t\t     entityIndex < self.entityCache.length;\n\t\t     ++entityIndex ) {\n\t\t\tlookupTable[ self.entityCache[ entityIndex ].id ] = self.entityCache[ entityIndex ];\n\t\t}\n\t\treturn lookupTable;\n\t};\n\n\t/**\n\t * Reduce instances of complex types within an entity with their respective IDs.\n\t * Note that no type checks are being performed. Every nested object with an \"id\" property is treated as a complex type.\n\t * @param {Object} entity The entity that should have its complex member reduced.\n\t * @param {Boolean} [arrayInsteadOfObject=false] true if the manipulated entity is an array; false if it's an object.\n\t * @returns {Object|Array} A copy of the input entity, with complex type instances replaced with their respective ID.\n\t */\n\tCacheService.prototype.reduceComplex = function CacheService$reduceComplex( entity, arrayInsteadOfObject ) {\n\t\tvar self = this;\n\n\t\tvar result = arrayInsteadOfObject ? [] : {};\n\t\tfor( var propertyName in entity ) {\n\t\t\tif( !entity.hasOwnProperty( propertyName ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Recurse for nested arrays.\n\t\t\tif( Array.isArray( entity[ propertyName ] ) ) {\n\t\t\t\tresult[ propertyName ] = self.reduceComplex( entity[ propertyName ], true );\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Replace complex type with its ID.\n\t\t\tif( entity[ propertyName ] && entity[ propertyName ].id ) {\n\t\t\t\tresult[ propertyName ] = entity[ propertyName ].id;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Just copy over the plain property.\n\t\t\tresult[ propertyName ] = entity[ propertyName ];\n\t\t}\n\t\treturn result;\n\t};\n\n\t/**\n\t * Populate references to complex types in an instance.\n\t * @param {Object} entity The entity that should be manipulated.\n\t * @param {String} propertyName The name of the property of entity which should be populated.\n\t * @param {CacheService} cache An instance of another caching service that can provide the complex\n\t * type instances which are being referenced in entity.\n\t * @param {Boolean} [force=false] If true, all complex types will be replaced with references to the\n\t * instances in cache; otherwise, only properties that are string representations of complex type IDs will be replaced.\n\t * @returns {IPromise<TResult>|IPromise<any[]>|IPromise<{}>|angular.IPromise<TResult>}\n\t */\n\tCacheService.prototype.populateComplex = function CacheService$populateComplex( entity, propertyName, cache, force ) {\n\t\tvar self = this;\n\n\t\t// If the target property is an array, ...\n\t\tif( Array.isArray( entity[ propertyName ] ) ) {\n\t\t\t// ...map the elements in the array to promises.\n\t\t\tvar promises = entity[ propertyName ].map( mapElementToPromise );\n\n\t\t\treturn self.q.all( promises );\n\n\t\t} else {\n\t\t\t// We usually assume the properties to be strings (the ID of the referenced complex).\n\t\t\tif( typeof entity[ propertyName ] !== \"string\" ) {\n\t\t\t\t// If \"force\" is enabled, we check if this non-string property is an object and has an \"id\" member, which is a string.\n\t\t\t\tif( force && typeof entity[ propertyName ] === \"object\" && typeof entity[ propertyName ].id === \"string\" ) {\n\t\t\t\t\t// If that is true, then we replace the whole object with the ID and continue as usual.\n\t\t\t\t\tentity[ propertyName ] = entity[ propertyName ].id;\n\n\t\t\t\t} else {\n\t\t\t\t\treturn self.q.when( false );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Treat the property as an ID and read the complex with that ID from the cache.\n\t\t\treturn cache.read( entity[ propertyName ] )\n\t\t\t\t.then( onComplexRetrieved );\n\t\t}\n\n\t\tfunction mapElementToPromise( element, index ) {\n\t\t\t// We usually assume the properties to be strings (the ID of the referenced complex).\n\t\t\tif( typeof entity[ propertyName ][ index ] !== \"string\" ) {\n\t\t\t\t// If \"force\" is enabled, we check if this non-string property is an object and has an \"id\" member, which is a string.\n\t\t\t\tif( force && typeof entity[ propertyName ][ index ] === \"object\" && typeof entity[ propertyName ][ index ].id === \"string\" ) {\n\t\t\t\t\t// If that is true, then we replace the whole object with the ID and continue as usual.\n\t\t\t\t\tentity[ propertyName ][ index ] = entity[ propertyName ][ index ].id;\n\n\t\t\t\t} else {\n\t\t\t\t\treturn self.q.when( false );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Treat the property as an ID and read the complex with that ID from the cache.\n\t\t\treturn cache.read( entity[ propertyName ][ index ] )\n\t\t\t\t.then( onComplexRetrieved );\n\n\t\t\tfunction onComplexRetrieved( complex ) {\n\t\t\t\t// When the complex was retrieved, store it back into the array.\n\t\t\t\tentity[ propertyName ][ index ] = complex;\n\t\t\t\treturn entity;\n\t\t\t}\n\t\t}\n\n\t\tfunction onComplexRetrieved( complex ) {\n\t\t\t// When the complex was retrieved, store it back into the entity.\n\t\t\tentity[ propertyName ] = complex;\n\t\t}\n\t};\n\n\treturn CacheService;\n}\n\nfunction serializationNoop( model ) {\n\treturn model;\n}\n}());;(function() {\n\"use strict\";\n/* globals angular */\n\nangular\n\t.module( \"absync\" )\n\t.service( \"AbsyncServiceConfiguration\", AbsyncServiceConfigurationFactory );\n\nfunction AbsyncServiceConfigurationFactory() {\n\treturn AbsyncServiceConfiguration;\n}\n\n/**\n * Configuration for an absync service.\n * Using this type is entirely optional. Providing a hash with the same configuration options will work just fine.\n * @param {Object|String} model Reference to a constructor for the model type, or it's name.\n * If a name is given, absync will try to retrieve instances of the type through injection.\n * @param {String} collectionUri The REST API URI where the collection can be found.\n * Must not end with /\n * @param {String} entityUri The REST API URI where single entities out of the collection can be found.\n * Must not end with /\n * @param {String} [collectionName] The name of the collection. Uses the model name suffixed with \"s\" by default.\n * Using the default value is not recommended.\n * @param {String} [entityName] The name of an entity. Uses the model name by default.\n * Using the default value is not recommended.\n * @param {Function} [deserialize] A function that takes an object received from the server and turns it into a model.\n * By default, absync will just store the raw object without extending it to the model type.\n * Deserializers operate on the actual data received from the websocket.\n * @param {Function} [serialize] A function that takes a model and turns it into something the server expects.\n * By default, absync will just send the complete model.\n * Serializers operate on a copy of the actual model, which already had complex members reduced to their IDs.\n * @param {Function} [injector] An injector to use for model instantiation. Uses $injector by default.\n * Usually, you don't need to provide an alternative here.\n * @param {Boolean} [debug=false] Should additional debugging output be enabled?\n * @param {Object} [allowBrowserCache] A hash that controls the browsing caching behavior.\n * @constructor\n */\nfunction AbsyncServiceConfiguration( model, collectionUri, entityUri, collectionName, entityName, deserialize, serialize, injector, debug, allowBrowserCache ) {\n\tthis.model         = model;\n\tthis.collectionUri = collectionUri;\n\tthis.entityUri     = entityUri;\n\n\tvar _modelName      = model.prototype.constructor.name.toLowerCase();\n\tthis.collectionName = collectionName || ( _modelName + \"s\" );\n\tthis.entityName     = entityName || _modelName;\n\n\tthis.deserialize = deserialize || undefined;\n\tthis.serialize   = serialize || undefined;\n\n\tthis.injector = injector || undefined;\n\n\tthis.debug = debug || false;\n\n\tthis.allowBrowserCache = angular.merge( {}, {\n\t\tsync    : true,\n\t\trequest : true\n\t}, allowBrowserCache );\n}\n}());;(function() {\n\"use strict\";\n/* globals angular */\n\nangular\n\t.module( \"absync\" )\n\t.constant( \"absyncNoopLog\", {\n\t\tdebug : angular.noop,\n\t\tinfo  : angular.noop,\n\t\terror : angular.noop\n\t} );\n}());;(function() {\n\"use strict\";\n/* globals angular */\n\nangular\n\t.module( \"absync\" )\n\t.filter( \"absyncUncached\", uncachedFilterProvider );\n\nfunction uncachedFilterProvider() {\n\treturn uncachedFilter;\n\n\tfunction uncachedFilter( url ) {\n\t\tif( !url ) {\n\t\t\treturn url;\n\t\t}\n\n\t\tvar delimiter     = -1 < url.indexOf( \"?\" ) ? \"&\" : \"?\";\n\t\tvar discriminator = new Date().getTime();\n\n\t\treturn url + delimiter + \"t\" + discriminator;\n\t}\n}\n}());","/* globals angular */\n\n/**\n * Please make note of the following conventions:\n * 1. Function-scope local variables must be prefixed with a single underscore.\n *    This indicates a temporary variable.\n * 2. Private variables that are persisted onto publicly accessible entities must be prefixed with two underscores.\n *    This indicates a publicly visible, private variable.\n *    Hiding private variables, by using closures, is discouraged.\n *    Modifying these values from outside of absync is discouraged, but should be respected whenever possible.\n */\n\nangular\n\t.module( \"absync\" )\n\t.constant( \"absyncCache\", getServiceConstructor );\n\n/**\n * A closure to make the configuration available to the cache service.\n * @param {String} name The name of the service.\n * @param {AbsyncServiceConfiguration} configuration The configuration for this service.\n * @returns {CacheService}\n */\nfunction getServiceConstructor( name, configuration ) {\n\t// There is no code here, other than the CacheService definition, followed by \"return CacheService;\"\n\n\t/**\n\t * This service factory is the core of absync.\n\t * It returns a CacheService instance that is specialized to the given configuration.\n\t * This service will handle keep the stored collection in sync.\n\t * @param {angular.IHttpService|Object} $http\n\t * @param {angular.auto.IInjectorService|Object} $injector\n\t * @param {angular.ILogService|Object} $log\n\t * @param {angular.IQService|Object} $q\n\t * @param {angular.IRootScopeService|Object} $rootScope\n\t * @param {AbsyncService} absync\n\t * @param {Object} absyncNoopLog A log interface that does nothing.\n\t * @param {Object} absyncUncachedFilter A filter that mutates URLs so they will bypass the browser cache.\n\t * @returns {CacheService}\n\t * @ngInject\n\t */\n\tfunction CacheService( $http, $injector, $log, $q, $rootScope, absync, absyncNoopLog, absyncUncachedFilter ) {\n\t\tvar self = this;\n\n\t\t// Retrieve a reference to the model of the collection that is being cached.\n\t\tvar _injector         = configuration.injector || $injector;\n\t\tvar _injectorHasModel = _injector.has( configuration.model );\n\t\tif( !_injectorHasModel ) {\n\t\t\tthrow new Error( \"Unable to construct the '\" + name + \"' service, because the referenced model '\" + configuration.model + \"' is not available for injection.\" );\n\t\t}\n\t\tvar _model = ( typeof configuration.model === \"string\" ) ? _injector.get( configuration.model ) : configuration.model;\n\n\t\t// Retrieve the serialization methods.\n\t\tvar serializeModel   = _model.serialize || configuration.serialize || serializationNoop;\n\t\tvar deserializeModel = _model.deserialize || configuration.deserialize || serializationNoop;\n\n\t\t// Store configuration.\n\t\tself.name          = name;\n\t\tself.configuration = configuration;\n\n\t\t// The entity cache must be constructed as an empty array or object, to allow the user to place watchers on it.\n\t\t// We must never replace the cache with a new array or object, we must always manipulate the existing one.\n\t\t// Otherwise watchers will not behave as the user expects them to.\n\t\t/* @type {Array<configuration.model>|configuration.model} */\n\t\tself.entityCache      = configuration.collectionName ? [] : {};\n\t\t// The raw cache is data that hasn't been deserialized and is used internally.\n\t\tself.__entityCacheRaw = null;\n\n\t\t// Should request caching be used at all?\n\t\tself.enableRequestCache = true;\n\t\t// Cache requests made to the backend to avoid multiple, simultaneous requests for the same resource.\n\t\tself.__requestCache     = {};\n\t\t// When we make HTTP requests, the browser is generally allowed to cache the responses.\n\t\t// The server can control this behavior with cache control HTTPS headers.\n\t\t// However, at times it may be desirable to force the browser to always fetch fresh data from the backend.\n\t\t// This hash controls this behavior.\n\t\tself.allowBrowserCache = angular.merge( {}, {\n\t\t\t// Should browser caching be allowed for initial cache sync operations?\n\t\t\tsync    : true,\n\t\t\t// Should browser caching be allowed when we retrieve single entities from the backend?\n\t\t\trequest : true\n\t\t}, configuration.allowBrowserCache );\n\t\tself.__uncached        = absyncUncachedFilter;\n\n\t\t// TODO: Using deferreds is an anti-pattern and probably provides no value here.\n\t\tself.__dataAvailableDeferred    = $q.defer();\n\t\tself.__objectsAvailableDeferred = $q.defer();\n\t\t// A promise that is resolved once initial data synchronization has taken place.\n\t\tself.dataAvailable              = self.__dataAvailableDeferred.promise;\n\t\t// A promise that is resolved once the received data is extended to models.\n\t\tself.objectsAvailable           = self.__objectsAvailableDeferred.promise;\n\n\t\t// Use $http by default and expose it on the service.\n\t\t// This allows the user to set a different, possibly decorated, HTTP interface for this service.\n\t\tself.httpInterface = $http;\n\t\t// Do the same for our logger.\n\t\tself.logInterface  = configuration.debug ? $log : absyncNoopLog;\n\t\t// The scope on which we broadcast all our relevant events.\n\t\tself.scope         = $rootScope;\n\t\t// Keep a reference to $q.\n\t\tself.q             = $q;\n\n\t\t// Prefix log messages with this string.\n\t\tself.logPrefix = \"absync:\" + name.toLocaleUpperCase() + \" \";\n\n\t\t// If enabled, entities received in response to a create or update API call, will be put into the cache.\n\t\t// Otherwise, absync will wait for them to be published through the websocket channel.\n\t\tself.forceEarlyCacheUpdate = false;\n\n\t\t// Throws failures so that they can be handled outside of absync.\n\t\t// Note: This will become the default in future versions.\n\t\tself.throwFailures = false;\n\n\t\t// Expose the serializer/deserializer so that they can be adjusted at any time.\n\t\tself.serializer   = serializeModel;\n\t\tself.deserializer = deserializeModel;\n\n\t\t// Tell absync to register an event listener for both our entity and its collection.\n\t\t// When we receive these events, we broadcast an equal Angular event on the root scope.\n\t\t// This way the user can already peek at the data (manipulating it is discouraged though).\n\t\tabsync.on( configuration.entityName, self.__onEntityOnWebsocket.bind( self ) );\n\t\tif( configuration.collectionName ) {\n\t\t\tabsync.on( configuration.collectionName, self.__onCollectionOnWebsocket.bind( self ) );\n\t\t}\n\n\t\t// Now we listen on the root scope for the same events we're firing above.\n\t\t// This is where our own absync synchronization logic kicks in.\n\t\t$rootScope.$on( configuration.entityName, self.__onEntityReceived.bind( self ) );\n\t\tif( configuration.collectionName ) {\n\t\t\t$rootScope.$on( configuration.collectionName, self.__onCollectionReceived.bind( self ) );\n\t\t}\n\n\t\t// Wait for data to be available.\n\t\tself.dataAvailable\n\t\t\t.then( self.__onDataAvailable.bind( self ) );\n\n\t\tself.logInterface.info( self.logPrefix + \"service was instantiated.\" );\n\t}\n\n\t/**\n\t * Invoked when an entity is received on a websocket.\n\t * Translates the websocket event to an Angular event and broadcasts it on the scope.\n\t * @param {Object} message\n\t * @private\n\t */\n\tCacheService.prototype.__onEntityOnWebsocket = function CacheService$onEntityOnWebsocket( message ) {\n\t\tvar self = this;\n\t\tself.scope.$broadcast( configuration.entityName, message[ configuration.entityName ] );\n\t};\n\n\t/**\n\t * Invoked when a collection is received on a websocket.\n\t * Translates the websocket event to an Angular event and broadcasts it on the scope.\n\t * @param {Object} message\n\t * @private\n\t */\n\tCacheService.prototype.__onCollectionOnWebsocket = function CacheService$onCollectionOnWebsocket( message ) {\n\t\tvar self = this;\n\t\tself.scope.$broadcast( configuration.collectionName, message[ configuration.collectionName ] );\n\t};\n\n\t/**\n\t * Event handler for when the initial badge of raw data becomes available.\n\t * @param {Array<Object>|Object} rawData\n\t * @private\n\t */\n\tCacheService.prototype.__onDataAvailable = function CacheService$onDataAvailable( rawData ) {\n\t\tvar self = this;\n\n\t\tif( Array.isArray( self.entityCache ) ) {\n\t\t\t// The symbol self.entityCache is expected to be an empty array.\n\t\t\t// We initialize it in the constructor to an empty array and we don't expect any writes to have\n\t\t\t// happened to it. In case writes *did* happen, we assume that whoever wrote to it knows what\n\t\t\t// they're doing.\n\t\t\trawData[ configuration.collectionName ].forEach( deserializeCollectionEntry );\n\n\t\t\t// Resolve our \"objects are available\" deferred.\n\t\t\t// TODO: We could just as well initialize objectAvailable to the return value of this call block.\n\t\t\tself.__objectsAvailableDeferred.resolve( self.entityCache );\n\n\t\t\t// Notify the rest of the application about a fresh collection.\n\t\t\tself.scope.$broadcast( \"collectionNew\", {\n\t\t\t\tservice : self,\n\t\t\t\tcache   : self.entityCache\n\t\t\t} );\n\n\t\t} else {\n\t\t\tvar deserialized = self.deserializer( rawData[ configuration.entityName ] );\n\t\t\tself.__updateCacheWithEntity( deserialized );\n\n\t\t\t// Resolve our \"objects are available\" deferred.\n\t\t\t// TODO: We could just as well initialize objectAvailable to the return value of this call block.\n\t\t\tself.__objectsAvailableDeferred.resolve( self.entityCache );\n\t\t}\n\n\t\tfunction deserializeCollectionEntry( rawEntity ) {\n\t\t\tself.entityCache.push( self.deserializer( rawEntity ) );\n\t\t}\n\t};\n\n\t/**\n\t * Event handler for when an entity is received on the root scope.\n\t * @param {Object} event The event object.\n\t * @param {Object} args The raw object as it was read from the wire.\n\t * @private\n\t */\n\tCacheService.prototype.__onEntityReceived = function CacheService$onEntityReceived( event, args ) {\n\t\tvar self            = this;\n\t\tvar _entityReceived = args;\n\n\t\t// Determine if the received record consists ONLY of an id property,\n\t\t// which would mean that this record was deleted from the backend.\n\t\tif( 1 === Object.keys( _entityReceived ).length && _entityReceived.hasOwnProperty( \"id\" ) ) {\n\t\t\tself.logInterface.info( self.logPrefix + \"Entity was deleted from the server. Updating cache…\" );\n\t\t\tself.__removeEntityFromCache( _entityReceived.id );\n\n\t\t} else {\n\t\t\tself.logInterface.debug( self.logPrefix + \"Entity was updated on the server. Updating cache…\" );\n\t\t\tself.__updateCacheWithEntity( self.deserializer( _entityReceived ) );\n\t\t}\n\t};\n\n\t/**\n\t * Event handler for when a collection is received on the root scope.\n\t * @param {Object} event The event object.\n\t * @param {Array<Object>} args The raw collection as it was read from the wire.\n\t * @private\n\t */\n\tCacheService.prototype.__onCollectionReceived = function CacheService$onCollectionReceived( event, args ) {\n\t\tvar self                = this;\n\t\tvar _collectionReceived = args;\n\n\t\t// When we're receiving a full collection, all data we currently have in our cache is useless.\n\t\t// We reset the length of the array here, because assigning a new array would possibly conflict\n\t\t// with watchers placed on the original object.\n\t\tself.entityCache.length = 0;\n\n\t\t// Deserialize the received data and place the models in our cache.\n\t\t_collectionReceived.forEach( addEntityToCache );\n\n\t\tfunction addEntityToCache( entityReceived ) {\n\t\t\tvar deserialized = self.deserializer( entityReceived );\n\t\t\tself.__updateCacheWithEntity( deserialized );\n\t\t}\n\t};\n\n\t/**\n\t * Ensure that the cached collection is retrieved from the server.\n\t * @param {Boolean} [forceReload=false] Should the data be loaded, even if the service already has a local cache?\n\t * @returns {Promise<Array<configuration.model>>|IPromise<Array>|IPromise<void>|Q.Promise<Array<configuration.model>>|angular.IPromise<TResult>}\n\t */\n\tCacheService.prototype.ensureLoaded = function CacheService$ensureLoaded( forceReload ) {\n\t\tvar self = this;\n\n\t\tforceReload = forceReload === true;\n\n\t\t// We only perform any loading, if we don't have raw data cached yet, or if we're forced.\n\t\tif( null === self.__entityCacheRaw || forceReload ) {\n\t\t\tself.__entityCacheRaw = [];\n\n\t\t\tif( !configuration.collectionName || !configuration.collectionUri ) {\n\t\t\t\tif( configuration.entityName && configuration.entityUri ) {\n\t\t\t\t\tself.__entityCacheRaw = {};\n\t\t\t\t\tself.httpInterface\n\t\t\t\t\t\t.get( configuration.allowBrowserCache.sync ? configuration.entityUri : self.__uncached(\n\t\t\t\t\t\t\tconfiguration.entityUri ) )\n\t\t\t\t\t\t.then( onSingleEntityReceived, onSingleEntityRetrievalFailure );\n\n\t\t\t\t} else {\n\t\t\t\t\t// If the user did not provide information necessary to work with a collection, immediately return\n\t\t\t\t\t// a promise for an empty collection. The user could still use read() to grab individual entities.\n\t\t\t\t\treturn self.q.when( [] );\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tself.logInterface.info( self.logPrefix + \"Retrieving '\" + configuration.collectionName + \"' collection…\" );\n\t\t\t\tself.httpInterface\n\t\t\t\t\t.get( configuration.allowBrowserCache.sync ? configuration.collectionUri : self.__uncached(\n\t\t\t\t\t\tconfiguration.collectionUri ) )\n\t\t\t\t\t.then( onCollectionReceived, onCollectionRetrievalFailure );\n\t\t\t}\n\t\t}\n\n\t\t// Return a promise that is resolved once the data was read and converted to models.\n\t\t// When the promise is resolved, it will return a reference to the entity cache.\n\t\treturn self.q.all(\n\t\t\t[\n\t\t\t\tself.dataAvailable,\n\t\t\t\tself.objectsAvailable\n\t\t\t] )\n\t\t\t.then( function dataAvailable() {\n\t\t\t\treturn self.entityCache;\n\t\t\t} );\n\n\t\t/**\n\t\t * Invoked when the collection was received from the server.\n\t\t * @param {angular.IHttpPromiseCallbackArg|Object} serverResponse The reply sent from the server.\n\t\t */\n\t\tfunction onCollectionReceived( serverResponse ) {\n\t\t\tif( !serverResponse.data[ configuration.collectionName ] ) {\n\t\t\t\tthrow new Error( \"The response from the server was not in the expected format. It should have a member named '\" + configuration.collectionName + \"'.\" );\n\t\t\t}\n\n\t\t\tself.__entityCacheRaw = serverResponse.data;\n\t\t\tself.__dataAvailableDeferred.resolve( serverResponse.data );\n\t\t}\n\n\t\t/**\n\t\t * Invoked when there was an error while trying to retrieve the collection from the server.\n\t\t * @param {angular.IHttpPromiseCallbackArg|Object} serverResponse The reply sent from the server.\n\t\t */\n\t\tfunction onCollectionRetrievalFailure( serverResponse ) {\n\t\t\tself.logInterface.error( self.logPrefix + \"Unable to retrieve the collection from the server.\",\n\t\t\t\tserverResponse );\n\t\t\tself.__entityCacheRaw = null;\n\n\t\t\tself.scope.$emit( \"absyncError\", serverResponse );\n\t\t\tself.__dataAvailableDeferred.reject( serverResponse );\n\t\t}\n\n\t\t/**\n\t\t * Invoked when the entity was received from the server.\n\t\t * @param {angular.IHttpPromiseCallbackArg|Object} serverResponse The reply sent from the server.\n\t\t */\n\t\tfunction onSingleEntityReceived( serverResponse ) {\n\t\t\tif( !serverResponse.data[ configuration.entityName ] ) {\n\t\t\t\tthrow new Error( \"The response from the server was not in the expected format. It should have a member named '\" + configuration.entityName + \"'.\" );\n\t\t\t}\n\n\t\t\tself.__entityCacheRaw = serverResponse.data;\n\t\t\tself.__dataAvailableDeferred.resolve( serverResponse.data );\n\t\t}\n\n\t\t/**\n\t\t * Invoked when there was an error while trying to retrieve the entity from the server.\n\t\t * @param {angular.IHttpPromiseCallbackArg|Object} serverResponse The reply sent from the server.\n\t\t */\n\t\tfunction onSingleEntityRetrievalFailure( serverResponse ) {\n\t\t\tself.logInterface.error( self.logPrefix + \"Unable to retrieve the entity from the server.\",\n\t\t\t\tserverResponse );\n\t\t\tself.__entityCacheRaw = null;\n\n\t\t\tself.scope.$emit( \"absyncError\", serverResponse );\n\t\t\tself.__dataAvailableDeferred.reject( serverResponse );\n\t\t}\n\t};\n\n\tCacheService.prototype.sync = function CacheService$sync() {\n\t\tvar self = this;\n\t\treturn self.ensureLoaded( true );\n\t};\n\n\t/**\n\t * Read a single entity from the cache, or load it from the server if required.\n\t * The entity will be placed into the cache.\n\t * @param {String} id The ID of the entity to retrieve.\n\t * @param {Boolean} [forceReload=false] Should the entity be retrieved from the server, even if it is already in the cache?\n\t * @returns {Promise<configuration.model>|IPromise<TResult>|IPromise<void>|angular.IPromise<TResult>}\n\t */\n\tCacheService.prototype.read = function CacheService$read( id, forceReload ) {\n\t\tvar self = this;\n\n\t\tforceReload = forceReload === true;\n\n\t\tself.logInterface.debug( self.logPrefix + \"Requesting entity '\" + id + \"' (forceReload:\" + forceReload + \")…\" );\n\n\t\tif( !forceReload ) {\n\t\t\t// Check if the entity is in the cache and return instantly if found.\n\t\t\tfor( var entityIndex = 0, entity = self.entityCache[ 0 ];\n\t\t\t     entityIndex < self.entityCache.length;\n\t\t\t     ++entityIndex, entity = self.entityCache[ entityIndex ] ) {\n\t\t\t\tif( entity.id === id ) {\n\t\t\t\t\tself.logInterface.debug( self.logPrefix + \"Requested entity  '\" + id + \"' is served from cache.\" );\n\t\t\t\t\treturn self.q.when( entity );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tself.logInterface.debug( self.logPrefix + \"Requested entity  '\" + id + \"' is fetched from backend.\" );\n\n\t\treturn self.__requestEntity( id )\n\t\t\t.then( onEntityRetrieved, onEntityRetrievalFailure );\n\n\t\t/**\n\t\t * Invoked when the entity was retrieved from the server.\n\t\t * @param {angular.IHttpPromiseCallbackArg|Object} serverResponse The reply sent from the server.\n\t\t */\n\t\tfunction onEntityRetrieved( serverResponse ) {\n\t\t\tif( !serverResponse.data[ configuration.entityName ] ) {\n\t\t\t\tthrow new Error( \"The response from the server was not in the expected format. It should have a member named '\" + configuration.entityName + \"'.\" );\n\t\t\t}\n\n\t\t\t// Deserialize the object and place it into the cache.\n\t\t\t// We do not need to check here if the object already exists in the cache.\n\t\t\t// While it could be possible that the same entity is retrieved multiple times, __updateCacheWithEntity\n\t\t\t// will not insert duplicated into the cache.\n\t\t\tvar deserialized = self.deserializer( serverResponse.data[ configuration.entityName ] );\n\t\t\tself.__updateCacheWithEntity( deserialized );\n\t\t\treturn deserialized;\n\t\t}\n\n\t\t/**\n\t\t * Invoked when there was an error while trying to retrieve the entity from the server.\n\t\t * @param {angular.IHttpPromiseCallbackArg|Object} serverResponse The reply sent from the server.\n\t\t */\n\t\tfunction onEntityRetrievalFailure( serverResponse ) {\n\t\t\tself.logInterface.error( self.logPrefix + \"Unable to retrieve entity with ID '\" + id + \"' from the server.\",\n\t\t\t\tserverResponse );\n\t\t\tself.scope.$emit( \"absyncError\", serverResponse );\n\n\t\t\tif( self.throwFailures ) {\n\t\t\t\tthrow serverResponse;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Request an entity from the backend.\n\t * @param {String} id The ID of the entity.\n\t * @returns {Promise<configuration.model>|IPromise<TResult>|IPromise<void>|angular.IPromise<TResult>}\n\t * @private\n\t */\n\tCacheService.prototype.__requestEntity = function CacheService$requestEntity( id ) {\n\t\tvar self = this;\n\n\t\tif( self.enableRequestCache && self.__requestCache && self.__requestCache[ id ] ) {\n\t\t\tself.logInterface.debug( self.logPrefix + \"Entity request    '\" + id + \"' served from request cache.\" );\n\t\t\treturn self.__requestCache[ id ];\n\t\t}\n\n\t\tvar requestUri = configuration.entityUri + ( id ? ( \"/\" + id ) : \"\" );\n\n\t\t// Grab the entity from the backend.\n\t\tvar request = self.httpInterface\n\t\t\t.get( configuration.allowBrowserCache.request ? requestUri : self.__uncached( requestUri ) )\n\t\t\t.then( remoteRequestFromCache.bind( self, id ) );\n\n\t\tif( self.enableRequestCache && self.__requestCache ) {\n\t\t\tself.__requestCache[ id ] = request;\n\t\t}\n\n\t\treturn request;\n\n\t\tfunction remoteRequestFromCache( id, serverResponse ) {\n\t\t\tdelete self.__requestCache[ id ];\n\t\t\treturn serverResponse;\n\t\t}\n\t};\n\n\t/**\n\t * Updates an entity and persists it to the backend and the cache.\n\t * @param {configuration.model} entity\n\t * @return {Promise<configuration.model>|IPromise<TResult>|angular.IPromise<TResult>} A promise that will be resolved with the updated entity.\n\t */\n\tCacheService.prototype.update = function CacheService$update( entity ) {\n\t\tvar self = this;\n\n\t\t// First create a copy of the object, which has complex properties reduced to their respective IDs.\n\t\tvar reduced    = self.reduceComplex( entity );\n\t\t// Now serialize the object.\n\t\tvar serialized = self.serializer( reduced );\n\n\t\t// Wrap the entity in a new object, with a single property, named after the entity type.\n\t\tvar wrappedEntity                         = {};\n\t\twrappedEntity[ configuration.entityName ] = serialized;\n\n\t\t// Check if the entity has an \"id\" property, if it has, we will update. Otherwise, we create.\n\t\tif( \"undefined\" !== typeof entity.id ) {\n\t\t\treturn self.httpInterface\n\t\t\t\t.put( configuration.entityUri + \"/\" + entity.id, wrappedEntity )\n\t\t\t\t.then( afterEntityStored.bind( self ), onEntityStorageFailure.bind( self ) );\n\n\t\t} else {\n\t\t\t// Create a new entity\n\t\t\treturn self.httpInterface\n\t\t\t\t.post( configuration.collectionUri, wrappedEntity )\n\t\t\t\t.then( afterEntityStored.bind( self ), onEntityStorageFailure.bind( self ) );\n\t\t}\n\t};\n\n\tCacheService.prototype.patch = function CacheService$patch( entity ) {\n\t\tvar self = this;\n\n\t\t// First create a copy of the object, which has complex properties reduced to their respective IDs.\n\t\tvar reduced    = self.reduceComplex( entity );\n\t\t// Now serialize the object.\n\t\tvar serialized = self.serializer( reduced );\n\n\t\t// Wrap the entity in a new object, with a single property, named after the entity type.\n\t\tvar wrappedEntity                         = {};\n\t\twrappedEntity[ configuration.entityName ] = serialized;\n\n\t\t// Check if the entity has an \"id\" property, if it has, we will update. Otherwise, we create.\n\t\tif( \"undefined\" !== typeof entity.id ) {\n\t\t\treturn self.httpInterface\n\t\t\t\t.patch( configuration.entityUri + \"/\" + entity.id, wrappedEntity )\n\t\t\t\t.then( afterEntityStored.bind( self ), onEntityStorageFailure.bind( self ) );\n\n\t\t} else {\n\t\t\tthrow new Error( \"Attempted to patch an entity that was never stored on the server.\" );\n\t\t}\n\t};\n\n\t/**\n\t * Creates a new entity and persists it to the backend and the cache.\n\t */\n\tCacheService.prototype.create = CacheService.prototype.update;\n\n\t/**\n\t * Invoked when the entity was stored on the server.\n\t * @param {angular.IHttpPromiseCallbackArg|Object} serverResponse The reply sent from the server.\n\t */\n\tfunction afterEntityStored( serverResponse ) {\n\t\tvar self = this;\n\n\t\t// Writing an entity to the backend will usually invoke an update event to be\n\t\t// broadcast over websockets, where we would also retrieve the updated record.\n\t\t// We still put the updated record we receive here into the cache to ensure early consistency.\n\t\t// TODO: This might actually not be optimal. Consider only handling the websocket update.\n\t\tif( serverResponse.data[ configuration.entityName ] ) {\n\t\t\tvar newEntity = self.deserializer( serverResponse.data[ configuration.entityName ] );\n\n\t\t\t// If early cache updates are forced, put the return entity into the cache.\n\t\t\tif( self.forceEarlyCacheUpdate ) {\n\t\t\t\tself.__updateCacheWithEntity( newEntity );\n\t\t\t}\n\t\t\treturn newEntity;\n\t\t}\n\t\tthrow new Error( \"The response from the server was not in the expected format. It should have a member named '\" + configuration.entityName + \"'.\" );\n\t}\n\n\t/**\n\t * Invoked when there was an error while trying to store the entity on the server.\n\t * @param {angular.IHttpPromiseCallbackArg|Object} serverResponse The reply sent from the server.\n\t */\n\tfunction onEntityStorageFailure( serverResponse ) {\n\t\tvar self = this;\n\n\t\tself.logInterface.error( self.logPrefix + \"Unable to store entity on the server.\",\n\t\t\tserverResponse );\n\t\tself.logInterface.error( serverResponse );\n\t\tself.scope.$emit( \"absyncError\", serverResponse );\n\n\t\tif( self.throwFailures ) {\n\t\t\tthrow serverResponse;\n\t\t}\n\t}\n\n\t/**\n\t * Remove an entity from the cache and have it deleted on the backend.\n\t * @param {Object} entity\n\t */\n\tCacheService.prototype.delete = function CacheService$delete( entity ) {\n\t\tvar self = this;\n\n\t\tvar entityId = entity.id;\n\t\treturn self.httpInterface\n\t\t\t.delete( configuration.entityUri + \"/\" + entityId )\n\t\t\t.then( onEntityDeleted )\n\t\t\t.catch( onEntityDeletionFailed );\n\n\t\t/**\n\t\t * Invoked when the entity was deleted from the server.\n\t\t * @param {angular.IHttpPromiseCallbackArg|Object} serverResponse The reply sent from the server.\n\t\t */\n\t\tfunction onEntityDeleted( serverResponse ) {\n\t\t\treturn self.__removeEntityFromCache( entityId );\n\t\t}\n\n\t\t/**\n\t\t * Invoked when there was an error while trying to delete the entity from the server.\n\t\t * @param {angular.IHttpPromiseCallbackArg|Object} serverResponse The reply sent from the server.\n\t\t */\n\t\tfunction onEntityDeletionFailed( serverResponse ) {\n\t\t\tself.logInterface.error( serverResponse.data );\n\t\t\tself.scope.$emit( \"absyncError\", serverResponse );\n\n\t\t\tif( self.throwFailures ) {\n\t\t\t\tthrow serverResponse;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Put an entity into the cache or update the existing record if the entity was already in the cache.\n\t * @param {Object} entityToCache\n\t * @private\n\t */\n\tCacheService.prototype.__updateCacheWithEntity = function CacheService$updateCacheWithEntity( entityToCache ) {\n\t\tvar self = this;\n\n\t\tself.logInterface.info( self.logPrefix + \"Updating entity '\" + ( entityToCache.id || self.name ) + \"' in cache…\",\n\t\t\tentityToCache );\n\n\t\tif( !Array.isArray( self.entityCache ) ) {\n\t\t\t// Allow the user to intervene in the update process, before updating the entity.\n\t\t\tself.scope.$broadcast( \"beforeEntityUpdated\",\n\t\t\t\t{\n\t\t\t\t\tservice : self,\n\t\t\t\t\tcache   : self.entityCache,\n\t\t\t\t\tentity  : self.entityCache,\n\t\t\t\t\tupdated : entityToCache\n\t\t\t\t} );\n\n\t\t\tif( typeof self.entityCache.copyFrom === \"function\" ) {\n\t\t\t\tself.entityCache.copyFrom( entityToCache );\n\n\t\t\t} else {\n\t\t\t\tangular.extend( self.entityCache, entityToCache );\n\t\t\t}\n\n\t\t\t// After updating the entity, send another event to allow the user to react.\n\t\t\tself.scope.$broadcast( \"entityUpdated\",\n\t\t\t\t{\n\t\t\t\t\tservice : self,\n\t\t\t\t\tcache   : self.entityCache,\n\t\t\t\t\tentity  : self.entityCache\n\t\t\t\t} );\n\t\t\treturn;\n\t\t}\n\n\t\tvar found = false;\n\t\tfor( var entityIndex = 0, entity = self.entityCache[ 0 ];\n\t\t     entityIndex < self.entityCache.length;\n\t\t     ++entityIndex, entity = self.entityCache[ entityIndex ] ) {\n\t\t\tif( entity.id == entityToCache.id ) {\n\t\t\t\t// Allow the user to intervene in the update process, before updating the entity.\n\t\t\t\tself.scope.$broadcast( \"beforeEntityUpdated\",\n\t\t\t\t\t{\n\t\t\t\t\t\tservice : self,\n\t\t\t\t\t\tcache   : self.entityCache,\n\t\t\t\t\t\tentity  : self.entityCache[ entityIndex ],\n\t\t\t\t\t\tupdated : entityToCache\n\t\t\t\t\t} );\n\n\t\t\t\t// Use the \"copyFrom\" method on the entity, if it exists, otherwise use naive approach.\n\t\t\t\tvar targetEntity = self.entityCache[ entityIndex ];\n\t\t\t\tif( typeof targetEntity.copyFrom === \"function\" ) {\n\t\t\t\t\ttargetEntity.copyFrom( entityToCache );\n\n\t\t\t\t} else {\n\t\t\t\t\tangular.extend( targetEntity, entityToCache );\n\t\t\t\t}\n\n\t\t\t\tfound = true;\n\n\t\t\t\t// After updating the entity, send another event to allow the user to react.\n\t\t\t\tself.scope.$broadcast( \"entityUpdated\",\n\t\t\t\t\t{\n\t\t\t\t\t\tservice : self,\n\t\t\t\t\t\tcache   : self.entityCache,\n\t\t\t\t\t\tentity  : self.entityCache[ entityIndex ]\n\t\t\t\t\t} );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// If the entity wasn't found in our records, it's a new entity.\n\t\tif( !found ) {\n\t\t\tself.scope.$broadcast( \"beforeEntityNew\", {\n\t\t\t\tservice : self,\n\t\t\t\tcache   : self.entityCache,\n\t\t\t\tentity  : entityToCache\n\t\t\t} );\n\n\t\t\tself.entityCache.push( entityToCache );\n\n\t\t\tself.scope.$broadcast( \"entityNew\", {\n\t\t\t\tservice : self,\n\t\t\t\tcache   : self.entityCache,\n\t\t\t\tentity  : entityToCache\n\t\t\t} );\n\t\t}\n\t};\n\n\t/**\n\t * Removes an entity from the internal cache. The entity is not removed from the backend.\n\t * @param {String} id The ID of the entity to remove from the cache.\n\t * @private\n\t */\n\tCacheService.prototype.__removeEntityFromCache = function CacheService$removeEntityFromCache( id ) {\n\t\tvar self = this;\n\n\t\tfor( var entityIndex = 0, entity = self.entityCache[ 0 ];\n\t\t     entityIndex < self.entityCache.length;\n\t\t     ++entityIndex, entity = self.entityCache[ entityIndex ] ) {\n\t\t\tif( entity.id == id ) {\n\t\t\t\t// Before removing the entity, allow the user to react.\n\t\t\t\tself.scope.$broadcast( \"beforeEntityRemoved\", {\n\t\t\t\t\tservice : self,\n\t\t\t\t\tcache   : self.entityCache,\n\t\t\t\t\tentity  : entity\n\t\t\t\t} );\n\n\t\t\t\t// Remove the entity from the cache.\n\t\t\t\tself.entityCache.splice( entityIndex, 1 );\n\n\t\t\t\t// Send another event to allow the user to take note of the removal.\n\t\t\t\tself.scope.$broadcast( \"entityRemoved\", {\n\t\t\t\t\tservice : self,\n\t\t\t\t\tcache   : self.entityCache,\n\t\t\t\t\tentity  : entity\n\t\t\t\t} );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Retrieve an associative array of all cached entities, which uses the ID of the entity records as the key in the array.\n\t * This is a convenience method that is not utilized internally.\n\t * @returns {Array<configuration.model>}\n\t */\n\tCacheService.prototype.lookupTableById = function CacheService$lookupTableById() {\n\t\tvar self = this;\n\n\t\t// TODO: Keep a copy of the lookup table and only update it when the cached data updates\n\t\tvar lookupTable = [];\n\t\tfor( var entityIndex = 0;\n\t\t     entityIndex < self.entityCache.length;\n\t\t     ++entityIndex ) {\n\t\t\tlookupTable[ self.entityCache[ entityIndex ].id ] = self.entityCache[ entityIndex ];\n\t\t}\n\t\treturn lookupTable;\n\t};\n\n\t/**\n\t * Reduce instances of complex types within an entity with their respective IDs.\n\t * Note that no type checks are being performed. Every nested object with an \"id\" property is treated as a complex type.\n\t * @param {Object} entity The entity that should have its complex member reduced.\n\t * @param {Boolean} [arrayInsteadOfObject=false] true if the manipulated entity is an array; false if it's an object.\n\t * @returns {Object|Array} A copy of the input entity, with complex type instances replaced with their respective ID.\n\t */\n\tCacheService.prototype.reduceComplex = function CacheService$reduceComplex( entity, arrayInsteadOfObject ) {\n\t\tvar self = this;\n\n\t\tvar result = arrayInsteadOfObject ? [] : {};\n\t\tfor( var propertyName in entity ) {\n\t\t\tif( !entity.hasOwnProperty( propertyName ) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Recurse for nested arrays.\n\t\t\tif( Array.isArray( entity[ propertyName ] ) ) {\n\t\t\t\tresult[ propertyName ] = self.reduceComplex( entity[ propertyName ], true );\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Replace complex type with its ID.\n\t\t\tif( entity[ propertyName ] && entity[ propertyName ].id ) {\n\t\t\t\tresult[ propertyName ] = entity[ propertyName ].id;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Just copy over the plain property.\n\t\t\tresult[ propertyName ] = entity[ propertyName ];\n\t\t}\n\t\treturn result;\n\t};\n\n\t/**\n\t * Populate references to complex types in an instance.\n\t * @param {Object} entity The entity that should be manipulated.\n\t * @param {String} propertyName The name of the property of entity which should be populated.\n\t * @param {CacheService} cache An instance of another caching service that can provide the complex\n\t * type instances which are being referenced in entity.\n\t * @param {Boolean} [force=false] If true, all complex types will be replaced with references to the\n\t * instances in cache; otherwise, only properties that are string representations of complex type IDs will be replaced.\n\t * @returns {IPromise<TResult>|IPromise<any[]>|IPromise<{}>|angular.IPromise<TResult>}\n\t */\n\tCacheService.prototype.populateComplex = function CacheService$populateComplex( entity, propertyName, cache, force ) {\n\t\tvar self = this;\n\n\t\t// If the target property is an array, ...\n\t\tif( Array.isArray( entity[ propertyName ] ) ) {\n\t\t\t// ...map the elements in the array to promises.\n\t\t\tvar promises = entity[ propertyName ].map( mapElementToPromise );\n\n\t\t\treturn self.q.all( promises );\n\n\t\t} else {\n\t\t\t// We usually assume the properties to be strings (the ID of the referenced complex).\n\t\t\tif( typeof entity[ propertyName ] !== \"string\" ) {\n\t\t\t\t// If \"force\" is enabled, we check if this non-string property is an object and has an \"id\" member, which is a string.\n\t\t\t\tif( force && typeof entity[ propertyName ] === \"object\" && typeof entity[ propertyName ].id === \"string\" ) {\n\t\t\t\t\t// If that is true, then we replace the whole object with the ID and continue as usual.\n\t\t\t\t\tentity[ propertyName ] = entity[ propertyName ].id;\n\n\t\t\t\t} else {\n\t\t\t\t\treturn self.q.when( false );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Treat the property as an ID and read the complex with that ID from the cache.\n\t\t\treturn cache.read( entity[ propertyName ] )\n\t\t\t\t.then( onComplexRetrieved );\n\t\t}\n\n\t\tfunction mapElementToPromise( element, index ) {\n\t\t\t// We usually assume the properties to be strings (the ID of the referenced complex).\n\t\t\tif( typeof entity[ propertyName ][ index ] !== \"string\" ) {\n\t\t\t\t// If \"force\" is enabled, we check if this non-string property is an object and has an \"id\" member, which is a string.\n\t\t\t\tif( force && typeof entity[ propertyName ][ index ] === \"object\" && typeof entity[ propertyName ][ index ].id === \"string\" ) {\n\t\t\t\t\t// If that is true, then we replace the whole object with the ID and continue as usual.\n\t\t\t\t\tentity[ propertyName ][ index ] = entity[ propertyName ][ index ].id;\n\n\t\t\t\t} else {\n\t\t\t\t\treturn self.q.when( false );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Treat the property as an ID and read the complex with that ID from the cache.\n\t\t\treturn cache.read( entity[ propertyName ][ index ] )\n\t\t\t\t.then( onComplexRetrieved );\n\n\t\t\tfunction onComplexRetrieved( complex ) {\n\t\t\t\t// When the complex was retrieved, store it back into the array.\n\t\t\t\tentity[ propertyName ][ index ] = complex;\n\t\t\t\treturn entity;\n\t\t\t}\n\t\t}\n\n\t\tfunction onComplexRetrieved( complex ) {\n\t\t\t// When the complex was retrieved, store it back into the entity.\n\t\t\tentity[ propertyName ] = complex;\n\t\t}\n\t};\n\n\treturn CacheService;\n}\n\nfunction serializationNoop( model ) {\n\treturn model;\n}\n","/* globals angular */\n\nangular\n\t.module( \"absync\" )\n\t.service( \"AbsyncServiceConfiguration\", AbsyncServiceConfigurationFactory );\n\nfunction AbsyncServiceConfigurationFactory() {\n\treturn AbsyncServiceConfiguration;\n}\n\n/**\n * Configuration for an absync service.\n * Using this type is entirely optional. Providing a hash with the same configuration options will work just fine.\n * @param {Object|String} model Reference to a constructor for the model type, or it's name.\n * If a name is given, absync will try to retrieve instances of the type through injection.\n * @param {String} collectionUri The REST API URI where the collection can be found.\n * Must not end with /\n * @param {String} entityUri The REST API URI where single entities out of the collection can be found.\n * Must not end with /\n * @param {String} [collectionName] The name of the collection. Uses the model name suffixed with \"s\" by default.\n * Using the default value is not recommended.\n * @param {String} [entityName] The name of an entity. Uses the model name by default.\n * Using the default value is not recommended.\n * @param {Function} [deserialize] A function that takes an object received from the server and turns it into a model.\n * By default, absync will just store the raw object without extending it to the model type.\n * Deserializers operate on the actual data received from the websocket.\n * @param {Function} [serialize] A function that takes a model and turns it into something the server expects.\n * By default, absync will just send the complete model.\n * Serializers operate on a copy of the actual model, which already had complex members reduced to their IDs.\n * @param {Function} [injector] An injector to use for model instantiation. Uses $injector by default.\n * Usually, you don't need to provide an alternative here.\n * @param {Boolean} [debug=false] Should additional debugging output be enabled?\n * @param {Object} [allowBrowserCache] A hash that controls the browsing caching behavior.\n * @constructor\n */\nfunction AbsyncServiceConfiguration( model, collectionUri, entityUri, collectionName, entityName, deserialize, serialize, injector, debug, allowBrowserCache ) {\n\tthis.model         = model;\n\tthis.collectionUri = collectionUri;\n\tthis.entityUri     = entityUri;\n\n\tvar _modelName      = model.prototype.constructor.name.toLowerCase();\n\tthis.collectionName = collectionName || ( _modelName + \"s\" );\n\tthis.entityName     = entityName || _modelName;\n\n\tthis.deserialize = deserialize || undefined;\n\tthis.serialize   = serialize || undefined;\n\n\tthis.injector = injector || undefined;\n\n\tthis.debug = debug || false;\n\n\tthis.allowBrowserCache = angular.merge( {}, {\n\t\tsync    : true,\n\t\trequest : true\n\t}, allowBrowserCache );\n}\n","/* globals angular */\n\nangular\n\t.module( \"absync\" )\n\t.constant( \"absyncNoopLog\", {\n\t\tdebug : angular.noop,\n\t\tinfo  : angular.noop,\n\t\terror : angular.noop\n\t} );\n","/* globals angular */\n\nangular\n\t.module( \"absync\" )\n\t.filter( \"absyncUncached\", uncachedFilterProvider );\n\nfunction uncachedFilterProvider() {\n\treturn uncachedFilter;\n\n\tfunction uncachedFilter( url ) {\n\t\tif( !url ) {\n\t\t\treturn url;\n\t\t}\n\n\t\tvar delimiter     = -1 < url.indexOf( \"?\" ) ? \"&\" : \"?\";\n\t\tvar discriminator = new Date().getTime();\n\n\t\treturn url + delimiter + \"t\" + discriminator;\n\t}\n}\n"],"sourceRoot":"/source/"}